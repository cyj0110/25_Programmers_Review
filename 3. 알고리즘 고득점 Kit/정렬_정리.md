# 알고리즘 고득점 Kit

[Python] 

## 정렬

### Q1(K번째수) / LV1
```Python
def solution(array, commands):
    answer = []
    
    for command in commands:
        temp = []
        i, j, k = command[0], command[1], command[2]
        temp = sorted(array[i-1:j])
        answer.append(temp[k-1])
              
    return answer

if __name__ == "__main__":
    array = input()
    commands = input()
    
    result = solution(array, commands)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 temp를 for문을 돌때마다 초기화해준다.
2. i, j, k에 command 리스트의 0, 1, 2번째 인덱스의 원소를 할당한다.
3. array의 i-1부터 j-1까지의 원소들을 슬라이싱하여 정렬한 리스트를 temp에 저장한다.
4. temp의 k-1번째 인덱스를 answer에 붙인다.
5. 위 과정을 commands 리스트가 끝날때까지 반복한다.

***

### Q2(가장 큰 수) / LV2
```Python
# 알고리즘
# 1: 모든 조합 가능한 수(순열), 리스트화
# 2: 그 중 가장 큰 수 리턴

# 다른 알고리즘
# 1: 두자리 수는 한 자리 수로 분해하기
# 2: 내림차순 정렬한 값 리턴
# X <- 한자리 수로 분해하게 되면 역정렬시 원래 원소의 순서를 잃음

import itertools

def solution(numbers):
    answer = ''
#     temp = []
#     알고리즘 #1 (실패)    
#     for number in numbers:
#         if (number >= 10):
#             num_str = str(number)
#             for d in num_str:
#                 temp.append(d)
#         else:
#             temp.append(str(number))
    
#     temp = sorted(temp, reverse=True)
#     answer = ''.join(temp)

#     알고리즘 #2 (실패)
#     r = len(numbers)
    
#     for p in itertools.permutations(numbers, r):
#         t = list(p)
#         temp.append(''.join(map(str, t)))
        
#     answer = max(temp)

#     알고리즘 #3
    numbers = list(map(str, numbers))
    numbers.sort(key=lambda x: x*3, reverse=True)
    answer = str(int(''.join(numbers)))
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. 위 문제는 총 3가지의 방법을 시도하고 풀어내었다.
2. 첫 번째는 모든 원소를 일의 자리가 되도록 분해하고 내림차순 정렬하는 것인데, 이렇게 되면 원래 원소의 순서를 잃기 때문에 원하는 결과를 도출하지 못하였다.
3. 두 번째는 itertools 라이브러리를 사용해서 순열을 구해 그 중 가장 큰 값을 반환하는 것인데, 이렇게 되면 원하는 결과는 도출할 수 있지만, numbers 원소의 개수가 많아지면 시간 복잡도는 O(n!)이라 기하급수적으로 증가하는 문제가 있다.
4. 마지막 방법은 원소들을 3번 이어붙여 그 값들끼리 비교하고 내림차순 정렬하는 방법이다.
5. numbers의 원소는 0 이상 1,000 이하이므로 4번 이어붙여 비교하는 것이 맞으나, 3번으로 해도 정답으로 인정되었음.
6. 체감상 LV3 이상 난이도였음.

***

### Q3(H-Index) / LV2
```Python
def solution(citations):
    answer = 0
    citations.sort(reverse=True)
    
    for i in range(len(citations)):
        if (citations[i] >= i + 1):
            answer = i + 1
        else:
            break
    
    return answer

if __name__ == "__main__":
    citations = input()
    
    result = solution(citations)
    print(result)
```
**주요 개념 및 로직**
1. 인덱스 i는 0부터 시작한다고 할 때, citations[i] ≥ i+1 인 경우가 h-index의 후보이므로 citations 배열을 내림차순 정렬하고,
2. 그 중 i + 1가 최대일 때 break로 빠져나오고 그 때의 i + 1 값이 h-index의 최댓값이다.

***
