# 알고리즘 고득점 Kit

[Python] 

## 해시

### Q1(완주하지 못한 선수) / LV1
```Python
def solution(participant, completion):
    participant.sort()
    completion.sort()
    
    # 순서대로 비교
    for p, c in zip(participant, completion):
        if p != c:
            return p  # 일치하지 않으면 완주 못한 사람
    
    # 끝까지 같다면 마지막 사람이 완주 못한 사람
    return participant[-1]

if __name__ == "__main__":
    participant = input()
    completion = input()
    
    result = solution(participant, completion)
    print(result)
```
**주요 개념 및 로직**
1. 두 리스트를 정렬하고, for문으로 participant와 completion 리스트의 원소들을 p, c로 한번에 비교한다.
2. 만약 p와 c가 다른 부분이 생긴다면 p가 완주하지 못한 사람이고, 끝까지 같다면 participant의 마지막 원소는 버려지므로 마지막 사람이 완주하지 못한 사람이 된다.

***

### Q2(폰켓몬) / LV1
```Python
def solution(nums):
    answer = 0
    # 뽑는 개수
    select = len(nums) // 2
    # 리스트 중복 제거
    nums_set = set(nums)
    
    # set 길이보다 뽑는 개수가 많으면 set 길이가 최대의 방법
    if (len(nums_set) < select):
        answer = len(nums_set)
    # 둘의 길이가 같으면 아무거나 정답
    elif (len(nums_set) == select):
        answer = len(nums_set)
    # set 길이가 뽑는 개수보다 많으면 뽑는 개수가 최대의 방법
    else:
        answer = select
    
    return answer


if __name__ == "__main__":
    nums = list(map(int, input()))
    
    result = solution(nums)
    print(result)
```
**주요 개념 및 로직**
1. 뽑는 개수 select 변수를 선언하고, nums 리스트를 중복을 제거한 nums_set 집합을 만든다.
2. 뽑는 개수와 집합 원소 개수에 따라서 로직이 나뉜다:
3. 집합의 원소 개수보다 뽑는 개수가 많으면 집합의 원소 개수가 최대의 방법이고,
4. 둘의 길이가 같으면 둘 중 아무거나 선택해서 answer에 준다.
5. 집합의 원소 개수가 뽑는 개수보다 많으면 뽑는 개수가 최대의 방법이 된다.

***

### Q3(전화번호 목록) / LV2
```Python
def solution(phone_book):
    sorted_phone_book = sorted(phone_book)
    
    for i in range(len(sorted_phone_book) - 1):
        if (sorted_phone_book[i+1].startswith(sorted_phone_book[i])):
            return False
    return True

if __name__ == "__main__":
    phone_book = input()
    
    result = solution(phone_book)
    print(result)
```
**주요 개념 및 로직**
1. 사전 순으로 정렬하면 접두사인 번호는 항상 바로 뒤에 위치한다는 점을 이용해 sorted()를 이용해 정렬하고,
2. for문을 돌려 i와 i+1를 비교하며 i를 접두사로 사용하는 i+1 인덱스의 원소가 있을 경우, False로 바로 return하고, 그렇지 않으면 True로 return한다.

***

### Q4(의상) / LV2
```Python
def solution(clothes):
    answer = 1
    clothes_dict = {}
    
    for name, kind in clothes:
        clothes_dict[kind] = clothes_dict.get(kind, 0) + 1
        
    for value in clothes_dict.values():
        answer *= (value + 1)

    return answer - 1

if __name__ == "__main__":
    clothes = input()
    
    result = solution(clothes)
    print(result)
```
**주요 개념 및 로직**
1. clothers는 name, kind로 이루어진 2차원 배열이므로, clothes_dict 딕셔너리를 선언하여 for문으로 kind가 나올 때마다 해당 키 값이 있으면 그 값에 +1을 하고, 없으면 0으로 초기화하고 +1을 한다.
2. 그럼 clothes의 각 kind에 해당하는 값(개수)들이 있을 것이므로, 한번 더 for문을 통해 딕셔너리의 values들을 순회하며 value에 + 1을 하고 answer에 곱해준다.(해당 kind를 선택하지 않는 경우 포함)
3. 곱한 answer에 - 1 (모두 선택하지 않는 경우)를 제외하고 반환한다.

***

### Q5(베스트앨범) / LV3
```Python

