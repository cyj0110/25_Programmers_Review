# 입문 문제 정리

[Python] 

모든 문제 번호는 '정답률 높은 문제순' 정렬 되어 있는 문제들의 번호임.

실제 프로그래머스 사이트에서 문제의 순서는 추후 변경될 수 있으니 참고바람.

## 출력

### Q1(나머지 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 % num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '%' 연산자를 쓰면 나머지를 구할 수 있다.

***

### Q2(두 수의 차 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 - num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '-' 연산자를 쓰면 두 수의 차를 구할 수 있다.
  
***

### Q3(숫자 비교하기)
```Python
def solution(num1, num2):
    answer = 0
    if (num1 == num2):
        answer = 1
    else:
        answer = -1
        
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. if 문으로 num1과 num2가 같은지 비교한다.

***

### Q4(나이 출력)
```Python
def solution(age):
    answer = 0
    answer = 2022 - age + 1
    
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. 2022년 기준이므로 2022에서 age를 빼고 1을 더한다. (제한사항은 만 나이가 아님.)

***

### Q5(두 수의 나눗셈)
```Python
def solution(num1, num2):
    answer = 0
    answer = int((num1 / num2) * 1000)
    
    return answer

if __name__ == "__name__":
    num1, num2 = int(input())
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. (num1 / num2) * 1000 하여 int로 형변환하면 정수 부분이 추출된다.

***

### Q6(몫 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = int(num1 / num2)
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. num1을 num2로 나누기 위해 '/' 연산자를 사용하고, int로 형변환해준다.

***

### Q7(두 수의 곱 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 * num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '*' 연산자를 사용하면 두 수의 곱을 구할 수 있다.
  
***

### Q8(두 수의 합 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 + num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '+' 연산자를 사용하면 두 수의 합을 구할 수 있다.
  
***

### Q9(각도기)
```Python
def solution(angle):
    answer = 0
    
    if (angle > 0 and angle < 90):
        answer = 1
    elif (angle == 90):
        answer = 2
    elif (angle > 90 and angle < 180):
        answer = 3
    elif (angle == 180):
        answer = 4
    else:
        answer = -1

    return answer

if __name__ == "__main__":
    angle = int(input())
    
    result = solution(angle)
    print(result)
```
**주요 개념 및 로직**
1. 조건에 따라 if, elif, else로 적절히 분기하여 answer에 1~4의 값을 넣으면 된다.

***

### Q10(양꼬치)
```Python
def solution(n, k):
    answer = 0
    
    if (n < 10):
        answer = (n * 12000) + (k * 2000)
    else:
        m = int(n / 10)
        answer = (n * 12000) + ((k - m) * 2000)
        
    return answer

if __name__ == "__main__":
    n, k = int(input())
    
    result = solution(n, k)
    print(result)
```
**주요 개념 및 로직**
1. 양꼬치를 10인분 먹으면 음료수 하나를 서비스로 준다고 했으므로,
2. 양꼬치를 10인분 이상 먹었을 때와, 먹지 않았을 때로 나누고, 10인분 미만으로 먹었으면 서비스는 없으므로 먹은 인분만큼 가격을 곱하여 answer에 할당한다.
3. 양꼬치를 10인분 이상 먹었을 때는 서비스 개수를 담을 변수 m에 n을 10으로 나눈 몫을 정수로 저장하고, 음료수 개수에서 서비스 개수(m)를 뺀 인분만큼 가격을 곱하여 answer에 할당한다. (양꼬치는 동일)

***

### Q11(짝수의 합)
```Python
def solution(n):
    answer = 0
    
    for i in range(0, n+1):
        if (i % 2 == 0):
            answer += i
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0~n까지 숫자 중에 짝수인것만 answer에 더한다.

***

### Q12(배열의 평균값)
```Python
def solution(numbers):
    answer = 0
    
    numbers = list(numbers)
    answer = sum(numbers) / len(numbers)
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. sum() 함수와 len() 함수를 이용해 리스트의 평균값을 계산한다.

***

### Q13(배열 뒤집기)
```Python
def solution(num_list):
    answer = []
    num_list.reverse()
    
    answer = num_list
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. num_list.reverse() 함수로 num_list의 원소들을 뒤집고, answer에 할당한다.
2. 참고: num_list[::-1]를 사용하는 방법도 있다.

***

### Q14(뒤집힌 문자열)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    my_string.reverse()
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. String을 리스트로 바꿔주고, reverse()를 이용해 뒤집어준 뒤, ''.join() 메소드로 다시 String으로 바꿔준다.
2. 참고: String도 my_string[::-1] 슬라이싱이 가능하다.

***

### Q15(편지)
```Python
def solution(message):
    answer = 0
    
    message = list(message)
    answer = len(message) * 2
    
    return answer

if __name__ == "__main__":
    message = input()
    
    result = solution(message)
    print(result)
```
**주요 개념 및 로직**
1. message String을 리스트로 바꿔주고, 리스트(message)의 길이에 2를 곱해준 것이 가로 길이이므로, answer에 할당한다.

***

### Q16(피자 나눠 먹기 (1))
```Python
def solution(n):
    answer = 0
    
    if (n % 7 != 0):
        answer = n // 7 + 1
    else:
        answer = n // 7
        
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 7로 나눈 나머지가 0이 아닐 때는 n을 7로 나눈 몫에 1을 더하여준 값을 answer에 할당하고,
2. n을 7로 나눈 나머지가 0일 때는 n을 7로 나눈 몫을 answer에 할당한다.

***

### Q17(세균 증식)
```Python
def solution(n, t):
    answer = 0    
    answer = n * pow(2, t)
    return answer

if __name__ == "__main__":
    n, t = int(input())
    
    result = solution(n, t)
    print(result)
```
**주요 개념 및 로직**
1. 처음 세균의 마리 수(n)에 한 시간에 2배로 증식한다고 하였으므로, 2^t(시간) 만큼을 곱해주면 된다. (pow 함수)

***

### Q18(최댓값 만들기(1))
```Python
def solution(numbers):
    answer = 0
    
    #1
    # num1 = max(numbers)
    # numbers.remove(num1)
    # num2 = max(numbers)
    
    # answer = num1 * num2
    
    #2
    numbers.sort()
    answer = numbers[-1] * numbers[-2]
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. 첫 번째 방법: num1에 numbers의 최댓값을 넣고, 제거한다. 그 다음 최댓값을 num2에 넣고 두 값을 곱한 값을 answer에 할당한다.
2. 두 번째 방법: sort로 정렬시키고 맨 끝 원소와 맨 끝에서부터 두번째 원소를 곱해서 answer에 할당한다.

***

### Q19(자릿수 더하기)
```Python
def solution(n):
    answer = 0
    
    n = str(n)
    for i in range(len(n)):
        answer += int(n[i])
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 스트링으로 바꿔주고, n의 길이만큼 for문을 돌린다:
2. n의 인덱스 i에 해당하는 원소들을 정수형으로 형변환하고, answer에 계속 더해준다.

***

### Q20(머쓱이보다 키 큰 사람)
```Python
def solution(array, height):
    answer = 0
    
    for i in range(len(array)):
        if (height < array[i]):
            answer += 1
            
    return answer

if __name__ == "__main__":
    array = map(int, input())
    height = int(input())
    
    result = solution(array, height)
    print(result)
```
**주요 개념 및 로직**
1. array의 길이만큼 for문을 돌리는데, array의 원소가 height보다 큰 원소가 나타날 때, answer에 1을 더한다.(count 개념)

***

### Q21(삼각형의 완성조건 (1))
```Python
def solution(sides):
    answer = 0
    
    long = max(sides)
    sides.remove(long)
    if (sum(sides) > long):
        answer = 1
    else:
        answer = 2
    
    return answer

if __name__ == "__main__":
    sides = input()
    
    result = solution(sides)
    print(result)
```
**주요 개념 및 로직**
1. 가장 긴 변을 max()를 사용해 long 변수에 담아준다.
2. 그리고 long을 배열에서 제외해준 sides 배열의 원소의 합이 long보다 클 경우 삼각형의 완성 조건을 만족하므로 answer은 1, 아니면 2.

***

### Q22(배열 자르기)
```Python
def solution(numbers, num1, num2):
    answer = []
    answer = numbers[num1:num2+1]
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    num1, num2 = int(input())
    
    result = solution(numbers, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. 리스트의 슬라이싱을 사용하여 num1부터 num2+1까지 슬라이싱해준다.(마지막 인덱스의 원소를 포함시키기 위해 +1 을 해줌.)

***

### Q23(피자 나눠 먹기 (3))
```Python
def solution(slices, n):
    answer = 0
    
    if (n % slices == 0):
        answer = n / slices
    else:
        answer = int(n / slices + 1)
    
    return answer

if __name__ == "__main__":
    slices, n = int(input())
    
    result = solution(slices, n)
    print(result)
```
**주요 개념 및 로직**
1. 사람 수 n을 조각 slices로 나눈 나머지가 0이라면 딱 나눠떨어지는 것이므로, n을 slices로 나눈 몫을 answer에 할당하고,
2. 나머지가 0이 아니라면 n을 slices로 나눈 몫에 1을 더한 값을 int로 형변환하여 answer에 할당한다.

***

### Q24(점의 위치 구하기)
```Python
def solution(dot):
    answer = 0
    
    if (dot[0] > 0 and dot[1] > 0):
        answer = 1
    elif (dot[0] > 0 and dot[1] < 0):
        answer = 4
    elif (dot[0] < 0 and dot[1] > 0):
        answer = 2
    elif (dot[0] < 0 and dot[1] < 0):
        answer = 3
    
    return answer

if __name__ == "__main__":
    dot = list(map(int, input()))
    
    result = solution(dot)
    print(result)
```
**주요 개념 및 로직**
1. dot[0] = x, dot[1] = y 좌표라고 생각하고 조건문을 적절하게 분기하여 answer에 1, 2, 3, 4 중 하나의 값을 할당한다.

***

### Q25(배열의 유사도)
```Python
def solution(s1, s2):
    answer = 0
    
    for val in s1:
        if (val in s2):
            answer += 1

    return answer

if __name__ == "__main__":
    s1, s2 = input()
    
    result = solution(s1, s2)
    print(result)
```
**주요 개념 및 로직**
1. s1 리스트에 있는 원소들을 val에 담아 for문을 돌리는데, val 원소가 s2에도 있으면 answer의 개수를 하나씩 올린다.
2. 또 다른 풀이: len(set(s1)&set(s2)) <- 이런식으로 집합의 교집합 연산을 이용해서 구할 수도 있다.

***

### Q26(순서쌍의 개수)
```Python
def solution(n):
    answer = 0
    # pair_list = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer += 1
            # pair = (i, n // i)
            # pair_list.append(pair)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. i는 1부터 n+1 까지 반복한다:
2. n을 i로 나누어 떨어지면, 해당 값은 순서쌍이 되므로 answer에 +1을 해준다.
3. 주석 부분은 순서쌍을 튜플로 저장하는 부분. (문제에서는 필요없음.)

***

### Q27(n의 배수 고르기)
```Python
def solution(n, numlist):
    answer = []
    
    for num in numlist:
        if (num % n == 0):
            answer.append(num)
            
    # answer = [i for i in numlist if i%n==0]
            
    return answer

if __name__ == "__main__":
    n = int(input())
    numlist = list(map(int, input()))
    
    result = solution(n, numlist)
    print(result)
```
**주요 개념 및 로직**
1. numlist에 있는 원소들을 num에 담아 num을 n으로 나눴을 때 나머지가 0인(n의 배수인) 원소들만 answer 리스트에 붙인다.
2. 두 번째 방법은 리스트 컴프리헨션.

***

### Q28(배열 원소의 길이)
```Python
def solution(strlist):
    answer = []
    answer = [len(i) for i in strlist]
    
    # for i in strlist:
        # answer.append(len(i))
    
    return answer

if __name__ == "__main__":
    strlist = input()
    
    result = solution(strlist)
    print(result)
```
**주요 개념 및 로직**
1. strlist의 원소들 i의 길이들을 answer 리스트에 저장(리스트 컴프리헨션)
2. 다른 방법: for문을 이용한 방법

***

### Q29(아이스 아메리카노)
```Python
def solution(money):
    answer = []
    answer = [money // 5500, money % 5500]
    
    return answer

if __name__ == "__main__":
    money = int(input())
    
    result = solution(money)
    print(result)
```
**주요 개념 및 로직**
1. answer 배열은 money를 5500으로 나눈 정수 몫, money를 5500으로 나눈 나머지가 들어간다.

***

### Q30(문자열안에 문자열)
```Python
def solution(str1, str2):
    answer = 0
    
    if str2 in str1:
        answer = 1
    else:
        answer = 2
        
    # answer = 1 if str2 in str1 else 2
    
    return answer

if __name__ == "__main__":
    str1, str2 = input()
    
    result = solution(str1, str2)
    print(result)
```
**주요 개념 및 로직**
1. str2가 str1 안에 있으면 answer은 1, 없으면 2.
2. 두 번째 방법은 pythonic한 방법.

***

### Q31(문자 반복 출력하기)
```Python
def solution(my_string, n):
    answer = ''
    for i in range(len(my_string)):
        answer += my_string[i] * n
    return answer

if __name__ == "__main__":
    my_string = input()
    n = int(input())
    
    result = solution(my_string, n)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌려서 my_string의 한 글자씩 n을 곱하여 answer에 더한다.

***

### Q32(제곱수 판별하기)
```Python
def solution(n):
    answer = 0
    k = n ** 0.5
    answer = 1 if k % 1 == 0 else 2
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n에 2/1 제곱을 한 수를 k라 하고, k를 1로 나눈 나머지가 0, 즉 정수일 때 answer에 1을 할당하고, 아니면 2를 할당한다.

***

### Q33(특정 문자 제거하기)
```Python
def solution(my_string, letter):
    answer = ''
    
    for i in range(len(my_string)):
        if (my_string[i] != letter):
            answer += my_string[i]
            
    return answer

if __name__ == "__main__":
    my_string = input()
    letter = input()
    
    result = solution(my_string, letter)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌리는데, my_string의 문자가 letter와 같지 않은 것만 answer에 더한다.

***

### Q34(모음 제거)
```Python
def solution(my_string):
    answer = ''
    vowel_list = ['a', 'e', 'i', 'o', 'u']
    
    for i in range(len(my_string)):
        if (my_string[i] not in vowel_list):
            answer += my_string[i]

    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 모음 리스트 vowel_list에 a, e, i, o, u를 넣어준다.
2. my_string의 길이만큼 for문을 돌려서 my_string의 문자가 vowel_list에 있지 않은 문자(자음)만 answer에 더한다.

***

### Q35(짝수 홀수 개수)
```Python
def solution(num_list):
    answer = []
    odd_count, even_count = 0, 0

    for num in num_list:
        if (num % 2 == 0):
            even_count += 1
        else:
            odd_count += 1
            
    answer.append(even_count)
    answer.append(odd_count)

    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 홀수, 짝수의 개수를 세는 변수를 0으로 초기화하고, num_list에 있는 원소들을 하나씩 순회하며 원소를 2로 나눈 나머지가 0(짝수)일때는 짝수 카운터에 1을, 홀수일때는 홀수 카운터에 1을 더한다.
2. 마지막에 answer 리스트에 짝수 카운터, 홀수 카운터의 값을 각각 붙여서 마무리한다.

***

### Q36(중복된 숫자 개수)
```Python
def solution(array, n):
    answer = 0
    
    answer = array.count(n)
    
    # for num in array:
    #     if (num == n):
    #         answer += 1
            
    return answer

if __name__ == "__main__":
    array = list(map(int , input()))
    n = int(input())
    
    result = solution(array, n)
    print(result)
```
**주요 개념 및 로직**
1. count()로 원소의 개수를 세는 방법이 있고, for문으로 해당 원소를 세는 방법이 있다.

***

### Q37(배열 두 배 만들기)
```Python
def solution(numbers):
    answer = []
    answer = [2 * i for i in numbers] # numbers에 있는 원소를 i라 할 때, 2 * i한 값들을 answer에 저장하라.
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers에 있는 원소를 i라 할 때, 2 * i 한 값들을 answer 리스트에 저장한다.

***

### Q38(중앙값 구하기)
```Python
def solution(array):
    answer = 0
    array = sorted(array)
    mid = len(array) // 2
    
    if len(array) % 2 == 1: # 홀수개
        answer = array[mid]
    else: # 짝수개
        answer = (array[mid-1] + array[mid]) / 2
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. array를 오름차순 정렬하고, mid 변수(array의 길이 / 2)를 선언한다.
2. array의 길이를 2로 나눈 나머지가 1이면 리스트의 개수가 홀수개이므로, 아까 선언한 mid가 중앙값이 된다.
3. 나머지가 0이면 리스트의 개수가 짝수개이므로, mid-1, mid를 더해 2로 나눈 값이 중앙값이 된다.

***

### Q39(짝수는 싫어요)
```Python
def solution(n):
    answer = []
    
    for i in range(n+1):
        if (i % 2 == 1):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0부터 n+1까지 for문을 돌려 i를 2로 나눈 나머지가 1(홀수)일 때만 answer에 붙인다.

***

### Q40(옷 가게 할인 받기)
```Python
def solution(price):
    answer = 0
    
    if (price >= 100000 and price < 300000):
        answer = price * 0.95
    elif (price >= 300000 and price < 500000):
        answer = price * 0.9
    elif (price >= 500000):
        answer = price * 0.8
    else:
        answer = price
    
    return int(answer)

if __name__ == "__main__":
    price = int(input())
    
    result = solution(price)
    print(result)
```
**주요 개념 및 로직**
1. price에 따라 조건문을 적절히 분기해 5%는 0.95, 10%는 0.9, 20%는 0.8을 곱하고, answer는 정수형으로 반환한다.

***

### Q41(직각삼각형 출력하기)
```Python
if __name__ == "__main__":
    n = int(input())
    for i in range(1, n+1):
        print("*" * i)
```
**주요 개념 및 로직**
1. for문의 범위는 1부터 n+1까지주고, 줄 마다 *의 개수를 i와 곱하여 출력하면 된다.

***

### Q42(개미 군단)
```Python
def solution(hp):
    answer = 0
    
    ant1 = hp // 5 # 장군개미
    ant2 = hp % 5 // 3 # 병정개미
    ant3 = hp % 5 % 3 // 1 # 일개미
    
    answer += ant1 + ant2 + ant3
    
    return answer

if __name__ == "__main__":
    hp = int(input())
    
    result = solution(hp)
    print(result)
```
**주요 개념 및 로직**
1. ant1을 장군개미의 수, ant2를 병정개미의 수, ant3을 일개미의 수로 나타내면 다음과 같다.
2. 각자 구한 최소 개체의 수를 다 더하여 answer에 더하면 최소한의 병력이 산출된다.

***

### Q43(가위 바위 보)
```Python
def solution(rsp):
    answer = ''
    rsp_list = ['2', '0', '5'] # 순서대로 가위, 바위, 보

    for i in range(len(rsp)):
        idx = rsp_list.index(str(rsp[i]))
        answer += rsp_list[(idx + 1) % 3]
            
    return answer

if __name__ == "__main__":
    rsp = input()
    
    result = solution(rsp)
    print(result)
```
**주요 개념 및 로직**
1. 가위바위보 리스트 rsp_list에 2, 0, 5를 순서대로 담아준다.
2. 받은 문자열 rsp의 길이만큼 for문을 돌려 현재 인덱스에 해당하는 원소를 idx로 담아준다.
3. answer에는 다음 인덱스(ex) 2 -> 0, 0 -> 5, 5 -> 2)에 해당하는 원소를 담아준다.

***

### Q44(주사위의 개수)
```Python
def solution(box, n):
    answer = 1
    
    for val in box:
        answer *= (val // n)

    return answer

if __name__ == "__main__":
    box = list(map(int, input()))
    n = int(input())
    
    result = solution(box, n)
    print(result)
```
**주요 개념 및 로직**
1. box에 있는 가로, 세로, 높이를 각각 val로 담아, val을 n으로 나눈 정수 몫을 다 곱하여 answer에 저장한다. (상자에 들어갈 수 있는 주사위의 최대 개수 나옴)
2. 단순히 가로 * 세로 * 높이를 한 부피에서는 남는 공간을 고려하지 못해 정확한 값이 나오지 않음.

***

### Q45(문자열 정렬하기 (1))
```Python
def solution(my_string):
    answer = []
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer.append(int(val))
            
    return sorted(answer)

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 문자도 0부터 9까지 정렬가능하므로 my_string의 원소 val이 0부터 9 사이에 있을 경우, answer 리스트에 int로 형변환하여 붙이고, 정렬된 answer 리스트를 반환한다.

***

### Q46(숨어있는 숫자의 덧셈 (1))
```Python
def solution(my_string):
    answer = 0
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer += int(val)
            
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 동일하게 숫자로 된 원소들을 int로 형변환하여 answer에 다 더한다.

***

### Q47(최댓값 만들기 (2))
```Python
def solution(numbers):
    numbers = sorted(numbers)
    
    cand1 = numbers[0] * numbers[1]
    cand2 = numbers[-1] * numbers[-2]
    answer = max(cand1, cand2)
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input().split()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers 리스트를 정렬하고, 음수와 음수를 곱한 최댓값과 양수와 양수를 곱한 최댓값을 cand1, cand2에 저장해서 둘 중 더 큰 것을 answer에 할당한다.

***

### Q48(암호 해독)
```Python
def solution(cipher, code):
    answer = ''
    
    for i in range(code-1, len(cipher), code):
        answer += cipher[i]
    
    return answer

if __name__ == "__main__":
    cipher = input()
    code = int(input())
    
    result = solution(cipher, code)
    print(result)
```
**주요 개념 및 로직**
1. code-1부터 cipher의 길이까지 step을 code크기로 cipher의 원소들을 answer에 붙인다.

***

### Q49(대문자와 소문자)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    
    for i in range(len(my_string)):
        if (my_string[i].islower()):
            my_string[i] = my_string[i].upper()
        elif (my_string[i].isupper()):
            my_string[i] = my_string[i].lower()
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트화 해주고, for문을 돌려서 my_string의 원소가 소문자인지, 대문자인지 판별 후, 소문자는 대문자로, 대문자는 소문자로 바꿔주는 작업을 실시한 후, 다시 string화 해준다.

***

### Q50(인덱스 바꾸기)
```Python
def solution(my_string, num1, num2):
    answer = ''
    my_string = list(my_string)
    
    temp = my_string[num1]
    my_string[num1] = my_string[num2] # 불변 객체라 스트링을 바로 바꿀 순 없음.
    my_string[num2] = temp # 마찬가지.
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    num1, num2 = int(input())
    
    result = solution(my_string, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트로 바꿔주고, temp에 num1 인덱스에 해당한 my_string 원소를 담아준다.
2. 그 후, num2 인덱스에 있던 원소를 num1 인덱스의 원소로 바꾸고,
3. num2 인덱스에 있던 원소를 temp로 바꾼다.
4. 마지막엔 다시 string화 시키기.

***

### Q51(약수 구하기)
```Python
def solution(n):
    answer = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 1부터 n+1까지 n을 i로 나눈 나머지가 0인 값(i가 n의 약수)만 answer에 붙인다.

***

### Q52(가장 큰 수 찾기)
```Python
def solution(array):
    answer = []
    answer = [max(array), array.index(max(array))]
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. answer에 array에서 가장 큰 값, 그 값의 인덱스를 담는다.

***

### Q53(문자열 정렬하기(2))
```Python
def solution(my_string):
    answer = ''
    my_string = my_string.lower()
        
    answer = ''.join(sorted(my_string))
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 전부 소문자로 바꾼 것을 정렬하여 스트링으로 바꿔주면 된다.

***

### Q54(숫자 찾기)
```Python
def solution(num, k):
    answer = 0
    num = str(num)
    k = str(k)
    
    if (k in num):
        answer = num.index(k) + 1
    else:
        answer = -1
              
    return answer

if __name__ == "__main__":
    num, k = int(input())
    
    result = solution(num, k)
    print(result)
```
**주요 개념 및 로직**
1. num과 k를 스트링을 바꿔주고, k가 num에 있으면 그 인덱스 + 1을 answer에, 없으면 -1을 answer에 담는다.

***

### Q55(피자 나눠 먹기(2))
```Python
def solution(n):
    answer = 0
    i = 1
    
    while(1):
        if ((6 * i) % n == 0):
            break
        i += 1
        
    answer = i
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 6판 * i를 n명 만큼 나눈 나머지가 0이 되는 로직을 통해 n명이 각자 똑같이 먹을 수 있는 최소 판을 구할 수 있다.
2. 초기에 i는 1부터 시작해 점점 증가하다가 n을 나눈 나머지가 0이 되는 순간 break를 통해 while문을 탈출한다. 그 i가 answer이다.

***

### Q56(외계행성의 나이)
```Python
def solution(age):
    answer = ''
    age = str(age)
    mapping = "abcdefghij"
    
    for num in age:
        answer += mapping[int(num)]
        
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. age를 string화 해주고, mapping 문자열에 a~j까지 둔다.
2. age에 있는 숫자들을 돌며 그 숫자를 int로 형변환한 것이 mapping의 인덱스로 들어가, 매핑된 값을 answer에 이어붙인다.

***

### Q57(배열 회전시키기)
```Python
def solution(numbers, direction):
    answer = []
    
    if (direction == "right"):
        for i in range(len(numbers)):
            answer.append(numbers[(i - 1) % len(numbers)])
    elif (direction == "left"):
        for i in range(len(numbers)):
            answer.append(numbers[(i + 1) % len(numbers)])
            
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    direction = input()
    
    result = solution(numbers, direction)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 answer에 direction이 left이면 numbers 리스트의 길이만큼 for문을 돌려 (i - 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (왼쪽으로 회전)
2. direction이 right이면 numbers 리스트의 길이만큼 for문을 돌려 (i + 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (오른쪽으로 회전)

***

### Q58(369게임)
```Python
def solution(order):
    answer = 0
    order = str(order)
    
    for num in order:
        if (int(num) != 0 and int(num) % 3 == 0):
            answer += 1
    
    return answer

if __name__ == "__main__":
    order = int(input())
    
    result = solution(order)
    print(result)
```
**주요 개념 및 로직**
1. order를 스트링으로 바꿔주고, int로 형변환된 각 숫자마다 0이 아니고, 3의 배수(3, 6, 9)일 때, answer에 1을 더한다.

***

### Q59(합성수 찾기)
```Python
def solution(n):
    answer = 0
    new_list = []
    
    for i in range(1, n+1):
        count = 0
        for j in range(1, i+1):
            if (i % j == 0):
                count += 1
        new_list.append(count)
    
    answer = len([x for x in new_list if x >= 3])

    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 합성수란 약수가 1과 자기 자신을 포함하여 개수가 3개 이상인 수를 말하므로, 우선 n 이하의 합성수의 개수를 구하기 위해 1부터 n까지의 수의 합성수를 담을 리스트 new_list를 선언,
2. for문을 돌려 count의 개수를 매번 0으로 초기화, 두번째 for문에서는 1부터 해당 원소(i)까지 해당 원소를 j(1~i)로 나눈 값이 0이되는 값이 있을 때 count의 개수를 1 증가시킨다.
3. 각 i의 for문이 끝나면 계산된 카운트를 new_list에 붙인다.
4. 모든 for문이 끝나고 나면 new_list에는 n이하의 정수들의 합성수들의 개수가 담겨있게 되므로, len()과 리스트 컴프리헨션을 통해 count가 3 이상인 것들만 골라 합성수의 개수를 찾아낸다.

***

### Q60(중복된 문자 제거)
```Python
def solution(my_string):
    answer = ''
    lst = []
    for val in my_string:
        if (val not in lst):
            lst.append(val)
            
    answer = ''.join(lst)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 문자들을 val이라고 했을 때, val이 lst에 없으면 val을 lst에 추가한다.
2. 마지막에 리스트 형태를 string으로 answer에 저장하고, 반환한다.

***

### Q61(모스부호 (1))
```Python
def solution(letter):
    answer = ''
    letter = list(letter.split(' '))
    morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
    }
    for i in range(len(letter)):
        answer += morse[letter[i]]
        
    return answer

if __name__ == "__main__":
    letter = input()
    
    result = solution(letter)
    print(result)
```
**주요 개념 및 로직**
1. letter을 받고, 공백으로 분리해 리스트로 만든다.
2. morse 딕셔너리는 문제에서 주어진 그대로이다.
3. for문을 letter 리스트 길이만큼 돌려 각 원소(키)를 주면 그에 맞는 문자가 반환되어 answer에 담긴다.

***

### Q62(2차원으로 만들기)
```Python
def solution(num_list, n):
    answer = []
    
    row = len(num_list) // n
    col = n
    k = 0
    
    for i in range(row):
        answer.append([])
        for j in range(col):
            answer[i].append(num_list[k])
            k += 1
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 행렬에서 사용될 row, col, k=0을 선언해주고,
2. 행 만큼 for문을 반복하여, 각 행마다 빈 리스트([])를 붙여주고, 열 만큼 for문을 반복하여, num_list의 원소들을 계속 가져와 answer의 각 행의 빈 리스트에 붙여넣는다.

***

### Q63(A로 B 만들기)
```Python
def solution(before, after):
    answer = 0
    answer = 1 if (sorted(before) == sorted(after)) else 0

    return answer

if __name__ == "__main__":
    before = input()
    after = input()
    
    result = solution(before, after)
    print(result)
```
**주요 개념 및 로직**
1. before 문장을 어떻게 조합해도 after와 같아지려면, 결국 구성하고 있는 문자의 개수가 같아야 한다.
2. 그렇기에, before 문장과 after 문장을 sorted()로 비교한 결과가 같으면 1, 같지 않으면 조합 불가능이므로 0이다.

***

### Q64(k의 개수)
```Python
def solution(i, j, k):
    answer = 0
    k = str(k)
    
    for num in range(i, j+1):
        answer += str(num).count(k)

    return answer

if __name__ == "__main__":
    i, j, k = int(input().split(' '))
    
    result = solution(i, j, k)
    print(result)
```
**주요 개념 및 로직**
1. 문자열로 비교하기 위해 k를 스트링으로 바꿔주고, i부터 j까지의 숫자도 string num으로 비교한다.
2. answer에는 num에 k가 들어있는 개수를 더하며 저장한다.

***

### Q65(한 번만 등장한 문자)
```Python
def solution(s):
    answer = ''
    answer = [x for x in set(s) if s.count(x) == 1]    
    answer = sorted(answer)
    
    return ''.join(answer)

if __name__ == "__main__":
    s = input()
    
    result = solution(s)
    print(result)
```
**주요 개념 및 로직**
1. 집합 s(s = {s에서 중복이 제거된 각 문자들})에서 문자들을 x라 하여 리스트에 저장한다.
2. 조건은 스트링 s에서 x(집합의 원소들)을 카운트한 것이 1인 원소들만 리스트에 저장한다.
3. answer은 리스트이므로, 반환할 때는 ''.join()을 사용해 스트링으로 바꿔준 뒤 반환한다.

***

### Q66(숨어있는 숫자의 덧셈 (2))
```Python
def solution(my_string):
    answer = 0
    current_char = ''
    
    for val in my_string:
        if val >= '0' and val <= '9':
            current_char += val
        else:
            if current_char:
                answer += int(current_char)
                current_char = ''
                
    if current_char:
        answer += int(current_char)
        
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 합계를 담을 answer, 현재 문자를 담을 current_char 변수를 선언하고,
2. my_string의 문자 하나씩 순회하며, val이 숫자인 경우, current_char에 담는다.
3. 그러다가 문자를 만난 경우, current_char에 있는 문자를 정수로 바꾼다음, answer에 더한다. currnet_char는 다음 숫자를 더하기 위해 빈 문자열로 초기화한다.
4. 모든 작업이 끝나고, 마지막이 숫자로 끝난 경우에 대비해, current_char에 남아있는 문자들을 정수로 바꾸어 answer에 더한다.

***

### Q67(7의 개수)
```Python
def solution(array):
    answer = 0
    array = ''.join(list(map(str, array)))
    answer = array.count('7')
    
    return answer

if __name__ == "__main__":
    array = input()
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. 정수형 리스트를 스트링 리스트로 바꾸고, string화 시켜주고,
2. 그 string에서 '7'의 개수를 찾아 answer에 저장한다.

***

### Q68(진료 순서 정하기)
```Python
def solution(emergency):
    answer = []
    
    sorted_emergency = sorted(emergency, reverse=True)
    answer = [sorted_emergency.index(x) + 1 for x in emergency]
    
    return answer

if __name__ == "__main__":
    emergency = list(map(int, input()))
    
    result = solution(emergency)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 큰 숫자가 진료 우선순위가 높으므로, emergency 리스트를 내림차순으로 정렬한 sorted_emergency를 만들어준다.
2. answer 리스트에는 emergency에 있는 원소가 순서대로 sorted_emergency 리스트에서 어떤 인덱스를 가지는지 뽑아와 리스트에 들어간다.

***

### Q69(팩토리얼)
```Python
def solution(n):
    fact = 1
    i = 1
    while (fact <= n):
        i += 1
        fact *= i
        
    answer = i - 1
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. factorial 값을 담을 변수 fact와 곱셈 변수 i를 1로 선언하고, fact 값이 n보다 작은 동안 while 문을 돌린다:
2. i에 1을 더하고, fact에 계속 곱해나간다.
3. 그러다가 fact 값이 어느순간 n을 넘게 되면 whlie문을 탈출하고, 넘게 된 값 이전의 값을 answer에 저장해야 하므로 i에 1을 빼서 저장한다.

***

### Q70(가까운 수)
```Python
def solution(array, n):    
    array.sort()
    temp = []

    for i in array :
        temp.append(abs(n-i))

    return array[temp.index(min(temp))]

if __name__ == "__main__":
    array = list(map(int, input()))
    n = int(input())
    
    result = solution(array, n)
    print(result)
```
**주요 개념 및 로직**
1. array의 원소 중 n과 i의 차가 같은 것이 있을 수 있으므로 정렬을 시킨다.
2. 빈 리스트 temp를 만들고, array의 원소를 하나씩 순회하며 temp에 n과 i의 차의 절댓값을 넣는다.
3. 그 중, 가장 작은 차를 갖는 원소의 인덱스를 array의 인덱스와 동일치시켜 그 값을 answer로 반환한다.

***

### Q71(컨트롤 제트)
```Python
def solution(s):
    answer = 0
    s = list(map(str, s.split(' ')))
    
    for i in range(len(s)):
        if (s[i] == 'Z'):
            answer -= int(s[i-1])
        else:
            answer += int(s[i])
            
    return answer

if __name__ == "__main__":
    s = input()
    
    result = solution(s)
    print(result)
```
**주요 개념 및 로직**
1. s 스트링을 공백으로 분리해 리스트화 시키고,
2. s의 길이만큼 for문을 돌려, 만약 현재 원소가 Z이면 그 전 원소의 값을 정수화시켜 answer에 저장하고,
3. Z가 아니면 현재 원소의 값을 정수화시켜 answer에 저장한다.

***

### Q72(잘라서 배열로 저장하기)
```Python
def solution(my_str, n):
    answer = []
    
    for i in range(0, len(my_str), n):
        answer.append(my_str[i:i+n])
        
    return answer

if __name__ == "__main__":
    my_str = input()
    n = int(input())
    
    result = solution(my_str, n)
    print(result)
```
**주요 개념 및 로직**
1. 0부터 my_str의 길이까지의 범위에 step은 n만큼 주고 for문을 돌린다:
2. my_str[i:i+n]까지 슬라이싱하여 answer에 더한다.

***

### Q73(소인수분해)
```Python
def solution(n):
    answer = []
    temp = []
    k = 2
    
    while (k <= n):
        if (n % k == 0):
            temp.append(k)
            n /= k
        else:
            k += 1
            
    for x in temp:
        if x not in answer:
            answer.append(x)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. k가 n보다 작거나 같을 때까지 while문으로 반복한다:
2. 만약 n이 k로 나누어 떨어질 때, k를 temp 리스트에 넣고, n은 k로 나눈 값으로 바꾼다.
3. 나누어 떨어지지 않으면, k의 값을 1 증가시킨다.
4. temp 리스트에는 소인수들이 담겨있지만, 중복된 값들도 있을 수 있으므로 중복제거를 한다.
5. temp의 원소들을 x로 하여, answer 리스트에 x가 없을때만 추가한다.

***

### Q74(문자열 계산하기)
```Python
def solution(my_string):
    my_string = my_string.split(' ')
    answer = int(my_string[0])
    
    # 연산자 순회
    for i in range(1, len(my_string), 2):
        op = my_string[i]
        num = int(my_string[i+1])
        
        if (op == '+'):
            answer += num
        elif (op == '-'):
            answer -= num

    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string 문장의 피연산자와 연산자를 구분하기 위해 공백을 기준으로 분리해 리스트로 만든다.
2. my_string의 첫번째 피연산자값을 answer에 정수형으로 변환해 담는다.
3. for문으로 첫번째 연산자부터 끝 연산자까지 순회한다:
4. 해당 연산자 값을 op에 담고, 계산할 피연산자 값을 num에 담는다.
5. 만약 해당 연산자가 '+'이면 num을 answer에 더하고, '-'이면 num을 answer에 뺀다.

***

### Q75(공 던지기)
```Python
def solution(numbers, k):
    answer = 0
    i = 0
    
    for _ in range(1, k+1):
        idx = numbers.index(numbers[i])
        i = (i + 2) % len(numbers)

    # 또는
    # for _ in range(1, k):
        # i = (i + 2) % len(numbers)

    # answer = numbers[i]

    # 또는
    # answer = numbers[(2 * (k - 1)) % len(numbers)]
    
    answer = numbers[idx]
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    k = int(input())
    
    result = solution(numbers, k)
    print(result)
```
**주요 개념 및 로직**
1. i의 초기값은 0, for문을 k번 반복한다:
2. idx에는 numbers[0]의 인덱스부터 i가 2개씩 뛰어넘는 numbers의 인덱스를 저장한다.
3. 그때의 numbers[idx] 값이 answer이다.
4. 또는 idx를 쓰지 않고 k번 만큼만 반복하여 i값에 바로 해당 인덱스를 담아준다.
5. 또는 (2 * (k - 1)) % len(numbers)로 간략화 시킨 인덱스를 numbers에서 바로 추출할 수도 있다.

***

### Q76(이진수 더하기)
```Python
def solution(bin1, bin2):
    answer = ''
    
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    answer = bin(num1 + num2)[2:]
    return answer

if __name__ == "__main__":
    bin1 = input()
    bin2 = input()
    
    result = solution(bin1, bin2)
    print(result)
```
**주요 개념 및 로직**
1. num1과 num2에 이진수 bin1과 bin2를 정수로 변환한 값을 각각 담고,
2. answer에는 num1과 num2를 더한 값을 다시 이진수로 변환시켜서 앞의 '0b'를 제거한 값을 담는다.

***

### Q77(영어가 싫어요)
```Python
def solution(numbers):
    answer = ''
    idx = 0
    number_list = {"one":1, "two":2, "three":3, "four":4, "five":5, "six":6, "seven":7, "eight":8, "nine":9, "zero":0}
    
    while(idx < len(numbers)):
        for word, digit in number_list.items():
            if (numbers[idx:].startswith(word)):
                answer += str(digit)
                idx += len(word)
                break        
            
    return int(answer)

if __name__ == "__main__":
    numbers = input()
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. number_list 딕셔너리를 만들어놓고, idx 값에 0을 주고 idx가 numbers 길이보다 작은동안 while문을 돌린다:
2. number_list에 있는 item들(word, digit) 값을 순회한다:
3. numbers의 idx로 시작하는 단어가 'one', 'two', ... 'zero'이면 그 에 해당하는 value 값(digit)을 answer에 스트링 형태로 넣고, 그 key(word)값의 길이만큼 idx를 더한다.
4. 단어를 찾았으니 break로 다음 구문을 찾는다. 최종적으로 다 변환한 뒤에는 다시 정수형으로 answer를 반환한다.

***

### Q78(구슬을 나누는 경우의 수)
```Python
def solution(balls, share):
    answer = 0
    cal_balls = 1
    cal_share = 1
    
    for i in range(balls, balls-share, -1):
        cal_balls *= i
    for i in range(1, share+1):
        cal_share *= i
    
    answer = cal_balls // cal_share
        
    return answer

if __name__ == "__main__":
    balls, share = map(int, input().split())
    
    result = solution(balls, share)
    print(result)
```
**주요 개념 및 로직**
1. 계산된 항목들을 나타내는 cal_balls, cal_share을 1로 선언하고
2. balls는 balls부터 balls-share까지 1씩 차감하며 for문을 돌려서 그 i 값을 cal_balls에 곱하고, (ex) balls = 5, share = 2 / cal_balls = 5 * 4)
3. share는 1부터 share+1까지 1씩 더하여 for문을 돌려서 그 i 값을 cal_share에 곱한다. (ex) balls = 5, share = 2 / cal_share = 1 * 2)
4. answer에는 cal_balls를 cal_share로 나눈 정수 몫을 반환한다.

***

### Q79(삼각형의 완성조건 (2))
```Python
def solution(sides):
    answer = 0
    
    # case1: 가장 긴 변이 sides 안에 있는 경우
    max_side = max(sides)
    other_side = min(sides)
    answer_side = max_side - other_side + 1
    case1_lst = []
    while (answer_side <= max_side):
        case1_lst.append(answer_side)
        answer_side += 1
    
    # case2: 가장 긴 변이 sides에 없는 경우
    side1 = max(sides)
    side2 = min(sides)
    answer_side = side1 + side2 - 1
    case2_lst = []
    while (answer_side > side1):
        case2_lst.append(answer_side)
        answer_side -= 1
        
    answer = len(case1_lst) + len(case2_lst)
    
    # 또는
    # answer = (sum(sides) - max(sides)) + (min(sides) - 1)
    
    return answer

if __name__ == "__main__":
    sides = list(map(int, input()))
    
    result = solution(sides)
    print(result)
```
**주요 개념 및 로직**
1. case1은 가장 긴 변이 sides 안에 있는 경우로 가장 긴 변과 나머지 변을 변수로 담아, 나머지가 될 수 있는 변 중에 가장 작은 변을 일단 answer_side에 담고, while문으로 1씩 증가하며 max_side보다 커질 때, 중단하는 방법
2. case2는 가장 긴 변이 sides 안에 없는 경우로, 나머지 두 변을 side1, side2에 담고, 가장 긴 변이 될 수 있는 변 중에 가장 큰 변을 일단 answer_side에 담고, while문으로 1씩 감소하며 side1(max side)보다 작아질 때, 중단하는 방법
3. case1_lst와 case2_lst의 개수를 더해 answer에 반환한다.
4. 간단하게 푸는 경우는 나머지 변이 될 수 있는 개수를 구하기 위해 두 변을 리스트에 넣고, 작은 변과 큰 변으로 계산하는 변형된 공식을 사용할 수 있다.
5. 핵심은 **|a-b| < c < a+b**이고, 가능한 값의 개수는 항상 **(a+b-1) - (|a-b|+1) +1**와 동일하다.

***

### Q80(캐릭터의 좌표)
```Python
def solution(keyinput, board):
    answer = []
    x, y = 0, 0
    wall_x, wall_y = board[0] // 2, board[1] // 2
    
    for action in keyinput:
        if (action == "left"):
            if (x - 1 < -wall_x):
                continue
            else:
                x -= 1
        elif (action == "right"):
            if (x + 1 > wall_x):
                continue
            else:
                x += 1
        elif (action == "up"):
            if (y + 1 > wall_y):
                continue
            else:
                y += 1
        elif (action == "down"):
            if (y - 1 < -wall_y):
                continue
            else:
                y -= 1
                
    answer = [x, y]
    return answer

if __name__ == "__main__":
    keyinput = input()
    board = input()
    
    result = solution(keyinput, board)
    print(result)
```
**주요 개념 및 로직**
1. 초기 x, y값을 0, 0을 주고, 경계 좌표 wall_x, wall_y를 board의 x, y 값을 2로 나눈 정수 몫으로 준다.
2. keyinput의 내용을 action으로 받아 for문을 돌린다:
3. action이 left일 때, 해당 입력에서 한 칸 더 왼쪽으로 갔을 때 경계좌표를 초과하면 continue, 아니면 x좌표에서 1을 뺀다.
4. action이 right일 때, 해당 입력에서 한 칸 더 오른쪽으로 갔을 때 경계좌표를 초과하면 continue, 아니면 x좌표에서 1을 더한다.
5. action이 up일 때, 해당 입력에서 한 칸 더 위로 갔을 때 경계좌표를 초과하면 continue, 아니면 y좌표에서 1을 더한다.
6. action이 down일 때, 해당 입력에서 한 칸 더 아래로 갔을 때 경계좌표를 초과하면 continue, 아니면 y좌표에서 1을 뺀다.
7. 최종적으로 action이 끝났을 때의 x, y 값을 answer에 담는다.

***

### Q81(외계어 사전)
```Python
def solution(spell, dic):
    answer = 0
    temp = []
    
    for word in dic:
        count = 0
        for char in spell:
            if (char in word):
                count += 1
            else:
                continue
                
        if len(spell) == count:
            temp.append(1)
    
    # 또는
    # for word in dic:
        # if sorted(word) == sorted(spell):    
        
    answer = 1 if 1 in temp else 2
        
    return answer

if __name__ == "__main__":
    spell = input()
    dic = input()
    
    result = solution(spell, dic)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 temp를 선언, dic에 있는 단어들을 하나씩 가져와 분석, count는 초기에는 항상 0.
2. spell에 있는 알파벳들을 char로 가져와서 word에 있는지 비교해 있을때마다 count에 1 증가, 없으면 continue.
3. 하나의 word를 검사하고 나면 계산된 count가 spell의 총 개수와 같은지 비교해 맞으면 temp에 1을 넣는다.
4. 모든 word를 다 검사하고 나서 temp에 하나라도 1이 있으면 answer은 1, 하나도 없으면 2를 반환한다.
5. sorted()로 비교하는 방법도 있다.

***

### Q82(종이 자르기)
```Python
def solution(M, N):
    answer = 0
    answer = (M - 1) + (M * (N - 1))
    return answer

if __name__ == "__main__":
    M, N = int(input())
    
    result = solution(M, N)
    print(result)
```
**주요 개념 및 로직**
1. 가로를 M, 세로를 N이라고 했을 때,
2. 가로를 한 번 잘랐을 때, 세로를 잘라야하는 개수는 M만큼 추가로 잘라야 하므로 (N - 1)에 M을 곱해주고, 가로와 세로를 잘라야 하는 횟수를 합해준다.

***

### Q83(로그인 성공?)
```Python
def solution(id_pw, db):
    answer = ''
    db = dict(db)
    
    if (id_pw[0] in db):
        if (id_pw[1] == db[id_pw[0]]):
            answer = 'login'
        else:
            answer = 'wrong pw'
    else:
        answer = 'fail'
        
    return answer

if __name__ == "__main__":
    id_pw = input()
    db = input()
    
    result = solution(id_pw, db)
    print(result)
```
**주요 개념 및 로직**
1. 이차원 리스트 db를 key-value 형태의 딕셔너리로 바꿔주고 시작한다.
2. id_pw[0], 즉 id가 db에 있는지 없는지부터 검사하여 없으면 answer에 fail을 준다.
3. id가 db에 있으면 id_pw[1], 즉 pw가 db의 value, 즉 id를 넣었을 때의 값과 비교하여 같으면 answer에 login을, 다르면 wrong pw를 준다.

***

### Q84(직사각형 넓이 구하기)
```Python
def solution(dots):
    answer = 0
    min_x, max_x, min_y, max_y = dots[0][0], dots[0][0], dots[0][1], dots[0][1]
    
    for dot in dots:
        if dot[0] > max_x:
            max_x = dot[0]
        if dot[0] < min_x:
            min_x = dot[0]
        if dot[1] > max_y:
            max_y = dot[1]
        if dot[1] < min_y:
            min_y = dot[1]
        
    answer = (max_x - min_x) * (max_y - min_y)
        
    return answer

if __name__ == "__main__":
    dots = input()
    
    result = solution(dots)
    print(result)
```
**주요 개념 및 로직**
1. dots의 x, y 값 중에서 가장 작은 x값, 가장 큰 x값, 가장 작은 y값, 가장 큰 y값을 모두 첫번째 dot의 x, y로 선언하고 시작한다.
2. dots의 dot들을 모두 순회하면서 현재 x나 y 값이 최대, 최소 x, y 값보다 크거나 작은 값이 있으면 그 값들을 max_x,y, min_x,y에 집어 넣는다.
3. answer은 (max_x - min_x)와 (max_y - min_y)를 곱한 값을 반환한다.

***

### Q85(치킨 쿠폰)
```Python
def solution(chicken):
    answer = -1
    coupons = chicken
    service = 0 # 서비스 치킨 수
    
    while (coupons >= 10):
        new_chicken = coupons // 10
        service += new_chicken
        coupons = coupons % 10 + new_chicken # 남은 쿠폰에 서비스로 먹은 치킨(쿠폰) 합하기
    answer = service
    
    return answer

if __name__ == "__main__":
    chicken = int(input())
    
    result = solution(chicken)
    print(result)
```
**주요 개념 및 로직**
1. 치킨을 먹은 만큼 쿠폰이 나온다고 했으므로, 전체 쿠폰 수를 chicken과 동일하게 맞추고, service로 먹은 치킨은 0으로 초기화한다.
2. 남은 쿠폰이 10개 미만이 될 때 까지 while문 진행:
3. 쿠폰으로 먹은 서비스 치킨도 쿠폰이 나온다고 했으므로, new_chicken에 전체 쿠폰에서 10개를 나눈 정수 몫을 넣고, 총 쿠폰으로 먹은 개수를 담는 변수인 service에 더한다.
4. 이제 쿠폰은 아까 전체 쿠폰에서 10을 나눈 나머지와 쿠폰으로 먹은 서비스 치킨에 해당하는 쿠폰을 더한 값으로 변경되어, 다시 while문을 돌게 된다.
5. 이걸 반복하여 남은 쿠폰이 10개 미만이 되면 while문을 탈출하여 answer에 총 쿠폰으로 먹은 개수 service를 준다.

***

### Q86(등수 매기기)
```Python
def solution(score):
    answer = []
    avg = []
    
    for each_score in score:
        eng_score = each_score[0]
        math_score = each_score[1]
        avg_score = (eng_score + math_score) / 2
        avg.append(avg_score)
            
    for i in range(len(avg)):
        cnt = 1
        for j in range(len(avg)):
            if (avg[j] > avg[i]):
                cnt += 1
        answer.append(cnt)
        
    return answer

if __name__ == "__main__":
    score = input()
    
    result = solution(score)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 avg를 선언하고, eng_score과 math_score를 each_score에서 각각 꺼내와 저장하고, 2를 나누어 평균 값을 계산하여, 그 값을 avg 리스트에 넣는다.
2. avg의 값을 i라 하고, cnt를 1로 선언, 안에 for문을 또 돌려서 avg의 현재 값과 avg에 있는 모든 값과 비교하여 앞서는 게 있을수록 cnt는 1이 증가되어 등수가 매겨짐.
3. avg의 현재 값이 for문을 다 돌면, cnt 값을 answer에 붙인다.

***

### Q87(저주의 숫자 3)
```Python
def solution(n):
    count = 0 # 유효한 숫자 개수
    num = 0   # 현재 숫자
    
    while (count < n):
        num += 1
        
        if num % 3 != 0:
            temp = num
            has_three = False
            while temp > 0:
                if temp % 10 == 3:
                    has_three = True
                    break
                temp //= 10
            if not has_three:
                count += 1
        
    answer = num
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. count와 num을 0으로 초기화하고, count가 n보다 작은 동안 while문으로 반복한다:
2. 현재 숫자를 1 증가 시켜 검사하는데, 3의 배수면 통과한다.
3. 3의 배수가 아니면 num을 복사한 값인 temp, 3이 있는지 검사하는 변수 has_three를 선언하고, 한 자리씩 체크하며 한 자리라도 3이 있으면 has_three는 True로 바뀐다.
4. temp의 동작을 끝내고 나면 has_three가 True인지 False인지 검사해 True이면 통과한 값이므로 count에 1을 증가시킨다.
5. 마지막으로 검사한 num 값이 바로 3x 마을에서의 n번째 수가 되므로 num을 최종적으로 반환한다.

***

### Q88(문자열 밀기)
```Python
def solution(A, B):
    if (A == B):
        return 0

    cnt = 0
    
    while (cnt < len(A)):
        A = A[-1] + A[:-1]
        cnt += 1
        if (A == B):
            return cnt
        
    return -1

if __name__ == "__main__":
    A = input()
    B = input()
    
    result = solution(A, B)
    print(result)
```
**주요 개념 및 로직**
1. A와 B가 시작부터 같은 경우는 바로 0을 반환한다.
2. count 변수를 0으로 초기화하고, cnt가 A의 길이만큼 돌도록 세팅한 후, while문을 돌린다:
3. A는 A의 마지막 원소와 처음부터 마지막 원소를 제외한 구간까지 슬라이싱된 문자열로 바뀌고, cnt에 1을 더한다.
4. 작업을 하다가 A와 B가 같아지는 순간의 cnt 값을 return한다.
5. 같아지는 순간이 없고, 한바퀴를 다 돌려서 처음 문자열의 A가 되었는데도, B 문자열이랑 같지 않은 경우는 -1을 반환한다.

***

### Q89(유한소수 판별하기)
```Python
import math

def solution(a, b):
    # 기약분수 만들기
    g = math.gcd(a, b)
    b = b // g # 분모를 기약분수로 만들기

    # 2와 5로 나누기
    while b % 2 == 0:
        b //= 2
    while b % 5 == 0:
        b //= 5

    # 최종 분모가 1이면 유한소수
    if b == 1:
        return 1
    else:
        return 2
    
    # 또는
    # 먼저 분모가 1이 되도록 a와 b 나누기
    # while a % 2 == 0 and b % 2 == 0:
        # a //= 2
        # b //= 2
    # while a % 5 == 0 and b % 5 == 0:
        # a //= 5
        # b //= 5

    # 이제 b에서 2와 5만 제거
    # while b % 2 == 0:
        # b //= 2
    # while b % 5 == 0:
        # b //= 5

    # 분모가 1이면 유한소수, 아니면 무한소수
    # return 1 if b == 1 else 2

if __name__ == "__main__":
    a, b = int(input())
    
    result = solution(a, b)
    print(result)
```
**주요 개념 및 로직**
1. 첫 번째 방법은 math 라이브러리를 이용해, gcd로 a와 b의 최대공약수를 구해 분모 b를 기약분수의 분모로 만들고 2와 5로 계속 나누어 최종적으로 1이면 유한소수, 2면 무한소수를 판별하는 로직이고,
2. 두 번째 방법은 math 라이브러리를 이용하지 않고, 기약분수를 만들기 위해 2와 5로 계속 나눈다. 기약분수의 분모 b에서 2와 5를 계속 나누어 최종적으로 1이면 유한소수, 2면 무한소수를 판별하는 로직이다.

***

### Q90(특이한 정렬)
```Python
def solution(numlist, n):
    answer = []
    temp = []
    cnt = 0
    # 알고리즘
    # numlist를 reverse로 큰 수부터 정렬
    # 각 원소들을 n으로부터 거리를 표시한 절댓값을 temp 배열에 저장
    # min_index = temp.index(min(temp))
    # answer.append(numlist[min_index])
    # 뽑아온 값은 10001로 변경
    # 작업을 카운트 하는 cnt 변수 0으로 선언하고, 이 len(temp)보다 작을때까지 수행
    
    numlist = sorted(numlist, reverse=True)
    for i in range(len(numlist)):
        diff = abs(n - numlist[i])
        temp.append(diff)
        
    while (cnt < len(temp)):
        min_index = temp.index(min(temp))
        answer.append(numlist[min_index])
        temp[min_index] = 10001
        cnt += 1
        
    return answer

if __name__ == "__main__":
    numlist = list(map(int, input()))
    n = int(input())
    
    result = solution(numlist, n)
    print(result)
```
**주요 개념 및 로직**
1. numlist를 큰 수부터 내림차순 정렬하고, numlist의 길이만큼 for문을 돌려, n과 numlist의 원소들의 차(거리)를 계산한 diff를 temp 리스트에 붙인다.
2. 그리고 시도 횟수 cnt는 0부터 temp의 길이보다 작을 동안 while문을 수행한다:
3. temp에서 가장 작은 원소 min의 인덱스를 min_index에 저장하고, numlist에서의 min_index 인덱스 값을 가진 원소를 answer 리스트에 붙인다.
4. temp에서 뽑아 왔던 min_index에 해당하는 원소는 추후, 다시 선택되지 않기 위해 문제에서의 최댓값 10000보다 하나 큰 10001로 준다.
5. 시도 횟수(cnt)를 1 증가 시킨다.
6. while문이 동작하고 나면, answer 리스트에는 정수 n을 기준으로 n과 가까운 수부터 정렬하는데 n으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치가 되어 있다.

***

### Q91(다항식 더하기)
```Python
def solution(polynomial):
    answer = ''
    polynomial = polynomial.replace(' ', '')
    terms = []
    i = 0
    x_coef = 0       # x항 계수 합
    constant = 0     # 상수항 합
    
    # +, - 로 분리하기
    while i < len(polynomial):
        if polynomial[i] in '+-':  # 새로운 항 시작
            sign = polynomial[i]
            i += 1
            start = i
            while i < len(polynomial) and polynomial[i] not in '+-':
                i += 1
            terms.append(sign + polynomial[start:i])
        else:  # 맨 처음 항 (부호 없을 수 있음)
            start = i
            while i < len(polynomial) and polynomial[i] not in '+-':
                i += 1
            terms.append(polynomial[start:i])
    
    # terms 리스트 순회하며 동류항끼리 계산
    while terms:
        term = terms.pop(0)
        if term[-1] == 'x':
            coef_str = term[:-1]
            coef = int(coef_str) if coef_str not in ['', '+', '-'] else 1
            if coef_str.startswith('-'):
                coef = -coef
            x_coef += coef
        else:
            constant += int(term)
    
    # 마지막 출력 형식 정리
    if x_coef != 0:
        if x_coef == 1:
            answer += "x"
        elif x_coef == -1:
            answer += "-x"
        else:
            answer += str(x_coef) + "x"
        
    if constant != 0:
        if answer != "" and constant > 0:
            answer += " + " + str(constant)
        else:
            answer += str(constant)
    
    return answer

if __name__ == "__main__":
    polynomial = input()
    
    result = solution(polynomial)
    print(result)
```
**주요 개념 및 로직**
1. 처음에 polynomial 스트링을 받으면 공백을 제거한다.
2. terms 리스트에 +, -를 기준으로 항 단위로 저장한다.
3. x항 계수의 합을 담을 변수 x_coef, 상수항의 합을 담을 변수 constant를 0으로 초기화 하고, terms 리스트에 있는 원소를 하나씩 꺼낸다:
4. term의 마지막 문자가 'x'이면 계수에 따라 각 계수를 정수형으로 저장하여 합하고, 상수항이면 상수를 정수로 저장하여 합한다.
5. 마지막 출력은 각 동류항끼리 계산한 것을 출력하는데, x의 계수가 1이면 x로 표시하고, -1이면 -x, 그외는 더해진 정수 계수를 x와 합하여 출력한다.
6. 또한, 상수항도 마찬가지로 출력하는데 음수이면 그대로 출력하고, 양수이면 +를 붙여서 출력한다.

***

### Q92(최빈값 구하기)
```Python
def solution(array):
    answer = 0
    array = sorted(array)
    count_dict = {}
    
    for num in array:
        if num in count_dict:
            count_dict[num] += 1
        else:
            count_dict[num] = 1
            
    max_value = max(count_dict.values())
    
    if list(count_dict.values()).count(max_value) > 1:
        answer = -1
    else:
        for key, value in count_dict.items():
            if value == max_value:
                answer = key
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 array를 정렬하고, 빈도수를 담을 딕셔너리 count_dict을 선언한다.
2. array에 있는 원소들을 num으로 하여 하나씩 순회하며, num이 count_dict에 있으면 그 num을 키로 하는 value(빈도)에 1을 더하고, 아니면 새롭게 key를 만들어 그 value(빈도)를 1로 한다.
3. for문 순회가 끝나고, count_dict에 있는 가장 큰 값(최빈값)을 max_value로 하고
4. 만약 count_dict의 value 값들만 리스트로 하여 그 최빈값(max_value)가 2개 이상일 때는 최빈값을 가지는 원소가 2개 이상이라는 뜻이므로 answer에 -1을 반환한다.
5. 그게 아니라면 count_dict를 key, value 형태로 순회하며 value가 max_value일 때의 key 값이 최빈값이 되므로 answer에 넣고 반환한다.

***

### Q93(OX퀴즈)
```Python
def solution(quiz):
    answer = []
    
    for query in quiz:
        parts = query.split()
        x, op, y, equal, z = parts
        
        x, y, z = int(x), int(y), int(z)
        
        if (op == '+'):
            if ((x + y) == z):
                answer.append("O")
            else:
                answer.append("X")
        elif (op == '-'):
            if ((x - y) == z):
                answer.append("O")
            else:
                answer.append("X")

    return answer

if __name__ == "__main__":
    quiz = input()
    
    result = solution(quiz)
    print(result)
```
**주요 개념 및 로직**
1. quiz의 각 수식들을 query로 담아 순회한다.
2. parts는 query의 각 문자들을 공백을 기준으로 분리하여 리스트로 저장한다.
3. parts 리스트에는 x(피연산자1), op(연산자), y(피연산자2), equal(=), z(결과값)로 담긴다.
4. x, y, z는 정수형이므로 정수로 변환한다.
5. op가 + 일때는 x + y 값과 z를 비교하여 같으면 answer에 O를 붙이고, 아니면 X를 넣고,
6. op가 - 일때는 x - y 값과 z를 비교하여 같으면 answer에 O를 붙이고, 아니면 X를 넣는다.

***

### Q94(다음에 올 숫자)
```Python
def solution(common):
    if (common[2]-common[1] == common[1]-common[0]): # 등차수열
        return common[-1] + (common[1] - common[0])
    else: # 등비수열
        return common[-1] * (common[2] // common[1])

if __name__ == "__main__":
    common = list(map(int, input()))
    
    result = solution(common)
    print(result)
```
**주요 개념 및 로직**
1. 리스트가 최소 3개의 원소를 갖는다고 가정하고, 리스트의 3번째 원소와 2번째 원소의 차가 2번째 원소와 1번째 원소와 같다면, 같은 공차를 갖는 등차수열이므로, 마지막 원소에 공차를 더한 값을 반환하고,
2. 같지 않다면 등비수열이므로, 마지막 원소에 공비(3번째 원소를 2번째 원소로 나눈 정수 몫)를 곱하여 반환한다.

***

### Q95(연속된 수의 합)
```Python
def solution(num, total):
    answer = []
    q = total // num  # 연속된 수의 중앙값 구하기
    
    # 리스트의 첫번째 숫자 구하기
    if num % 2 == 0:
        minus = num // 2 - 1
    else:
        minus = num // 2
    
    # 첫번째 숫자부터 +1하며 num번 연속된 숫자를 answer에 붙이기 
    for i in range(num):
        answer.append(q-minus + i)
        
    return answer

if __name__ == "__main__":
    num, total = int(input())
    
    result = solution(num, total)
    print(result)
```
**주요 개념 및 로직**
1. 연속된 수의 중앙값을 구하기 위해 total // num의 값을 q에 저장한다.
2. 연속된 수 리스트의 첫번째 원소를 구하기 위해 중앙값에서 빼야할 수를 구해야한다.
3. 연속된 수의 개수(num)가 짝수일 때는 num // 2 - 1 만큼을 minus에, 홀수일 때는 num // 2 만큼을 minus에 할당한다.
4. 이제 첫번째 원소가 정해졌으니, for문으로 첫번째부터 +1을 하며 num만큼 반복하여 그 숫자들을 리스트에 넣으면 된다.
5. answer에 붙이는 값은 중앙값(q)에서 뺄 값(minus)를 뺀 첫번째 원소부터 i만큼 더한 값을 붙인다.

***

### Q96(
