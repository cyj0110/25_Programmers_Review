# 입문 문제 정리

[Python] 

모든 문제 번호는 '정답률 높은 문제순' 정렬 되어 있는 문제들의 번호임.

실제 프로그래머스 사이트에서 문제의 순서는 추후 변경될 수 있으니 참고바람.

## 출력

### Q1(나머지 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 % num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '%' 연산자를 쓰면 나머지를 구할 수 있다.

***

### Q2(두 수의 차 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 - num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '-' 연산자를 쓰면 두 수의 차를 구할 수 있다.
  
***

### Q3(숫자 비교하기)
```Python
def solution(num1, num2):
    answer = 0
    if (num1 == num2):
        answer = 1
    else:
        answer = -1
        
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. if 문으로 num1과 num2가 같은지 비교한다.

***

### Q4(나이 출력)
```Python
def solution(age):
    answer = 0
    answer = 2022 - age + 1
    
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. 2022년 기준이므로 2022에서 age를 빼고 1을 더한다. (제한사항은 만 나이가 아님.)

***

### Q5(두 수의 나눗셈)
```Python
def solution(num1, num2):
    answer = 0
    answer = int((num1 / num2) * 1000)
    
    return answer

if __name__ == "__name__":
    num1, num2 = int(input())
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. (num1 / num2) * 1000 하여 int로 형변환하면 정수 부분이 추출된다.

***

### Q6(몫 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = int(num1 / num2)
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. num1을 num2로 나누기 위해 '/' 연산자를 사용하고, int로 형변환해준다.

***

### Q7(두 수의 곱 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 * num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '*' 연산자를 사용하면 두 수의 곱을 구할 수 있다.
  
***

### Q8(두 수의 합 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 + num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '+' 연산자를 사용하면 두 수의 합을 구할 수 있다.
  
***

### Q9(각도기)
```Python
def solution(angle):
    answer = 0
    
    if (angle > 0 and angle < 90):
        answer = 1
    elif (angle == 90):
        answer = 2
    elif (angle > 90 and angle < 180):
        answer = 3
    elif (angle == 180):
        answer = 4
    else:
        answer = -1

    return answer

if __name__ == "__main__":
    angle = int(input())
    
    result = solution(angle)
    print(result)
```
**주요 개념 및 로직**
1. 조건에 따라 if, elif, else로 적절히 분기하여 answer에 1~4의 값을 넣으면 된다.

***

### Q10(양꼬치)
```Python
def solution(n, k):
    answer = 0
    
    if (n < 10):
        answer = (n * 12000) + (k * 2000)
    else:
        m = int(n / 10)
        answer = (n * 12000) + ((k - m) * 2000)
        
    return answer

if __name__ == "__main__":
    n, k = int(input())
    
    result = solution(n, k)
    print(result)
```
**주요 개념 및 로직**
1. 양꼬치를 10인분 먹으면 음료수 하나를 서비스로 준다고 했으므로,
2. 양꼬치를 10인분 이상 먹었을 때와, 먹지 않았을 때로 나누고, 10인분 미만으로 먹었으면 서비스는 없으므로 먹은 인분만큼 가격을 곱하여 answer에 할당한다.
3. 양꼬치를 10인분 이상 먹었을 때는 서비스 개수를 담을 변수 m에 n을 10으로 나눈 몫을 정수로 저장하고, 음료수 개수에서 서비스 개수(m)를 뺀 인분만큼 가격을 곱하여 answer에 할당한다. (양꼬치는 동일)

***

### Q11(짝수의 합)
```Python
def solution(n):
    answer = 0
    
    for i in range(0, n+1):
        if (i % 2 == 0):
            answer += i
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0~n까지 숫자 중에 짝수인것만 answer에 더한다.

***

### Q12(배열의 평균값)
```Python
def solution(numbers):
    answer = 0
    
    numbers = list(numbers)
    answer = sum(numbers) / len(numbers)
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. sum() 함수와 len() 함수를 이용해 리스트의 평균값을 계산한다.

***

### Q13(배열 뒤집기)
```Python
def solution(num_list):
    answer = []
    num_list.reverse()
    
    answer = num_list
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. num_list.reverse() 함수로 num_list의 원소들을 뒤집고, answer에 할당한다.
2. 참고: num_list[::-1]를 사용하는 방법도 있다.

***

### Q14(뒤집힌 문자열)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    my_string.reverse()
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. String을 리스트로 바꿔주고, reverse()를 이용해 뒤집어준 뒤, ''.join() 메소드로 다시 String으로 바꿔준다.
2. 참고: String도 my_string[::-1] 슬라이싱이 가능하다.

***

### Q15(편지)
```Python
def solution(message):
    answer = 0
    
    message = list(message)
    answer = len(message) * 2
    
    return answer

if __name__ == "__main__":
    message = input()
    
    result = solution(message)
    print(result)
```
**주요 개념 및 로직**
1. message String을 리스트로 바꿔주고, 리스트(message)의 길이에 2를 곱해준 것이 가로 길이이므로, answer에 할당한다.

***

### Q16(피자 나눠 먹기 (1))
```Python
def solution(n):
    answer = 0
    
    if (n % 7 != 0):
        answer = n // 7 + 1
    else:
        answer = n // 7
        
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 7로 나눈 나머지가 0이 아닐 때는 n을 7로 나눈 몫에 1을 더하여준 값을 answer에 할당하고,
2. n을 7로 나눈 나머지가 0일 때는 n을 7로 나눈 몫을 answer에 할당한다.

***

### Q17(세균 증식)
```Python
def solution(n, t):
    answer = 0    
    answer = n * pow(2, t)
    return answer

if __name__ == "__main__":
    n, t = int(input())
    
    result = solution(n, t)
    print(result)
```
**주요 개념 및 로직**
1. 처음 세균의 마리 수(n)에 한 시간에 2배로 증식한다고 하였으므로, 2^t(시간) 만큼을 곱해주면 된다. (pow 함수)

***

### Q18(최댓값 만들기(1))
```Python
def solution(numbers):
    answer = 0
    
    #1
    # num1 = max(numbers)
    # numbers.remove(num1)
    # num2 = max(numbers)
    
    # answer = num1 * num2
    
    #2
    numbers.sort()
    answer = numbers[-1] * numbers[-2]
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. 첫 번째 방법: num1에 numbers의 최댓값을 넣고, 제거한다. 그 다음 최댓값을 num2에 넣고 두 값을 곱한 값을 answer에 할당한다.
2. 두 번째 방법: sort로 정렬시키고 맨 끝 원소와 맨 끝에서부터 두번째 원소를 곱해서 answer에 할당한다.

***

### Q19(자릿수 더하기)
```Python
def solution(n):
    answer = 0
    
    n = str(n)
    for i in range(len(n)):
        answer += int(n[i])
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 스트링으로 바꿔주고, n의 길이만큼 for문을 돌린다:
2. n의 인덱스 i에 해당하는 원소들을 정수형으로 형변환하고, answer에 계속 더해준다.

***

### Q20(머쓱이보다 키 큰 사람)
```Python
def solution(array, height):
    answer = 0
    
    for i in range(len(array)):
        if (height < array[i]):
            answer += 1
            
    return answer

if __name__ == "__main__":
    array = map(int, input())
    height = int(input())
    
    result = solution(array, height)
    print(result)
```
**주요 개념 및 로직**
1. array의 길이만큼 for문을 돌리는데, array의 원소가 height보다 큰 원소가 나타날 때, answer에 1을 더한다.(count 개념)

***

### Q21(삼각형의 완성조건 (1))
```Python
def solution(sides):
    answer = 0
    
    long = max(sides)
    sides.remove(long)
    if (sum(sides) > long):
        answer = 1
    else:
        answer = 2
    
    return answer

if __name__ == "__main__":
    sides = input()
    
    result = solution(sides)
    print(result)
```
**주요 개념 및 로직**
1. 가장 긴 변을 max()를 사용해 long 변수에 담아준다.
2. 그리고 long을 배열에서 제외해준 sides 배열의 원소의 합이 long보다 클 경우 삼각형의 완성 조건을 만족하므로 answer은 1, 아니면 2.

***

### Q22(배열 자르기)
```Python
def solution(numbers, num1, num2):
    answer = []
    answer = numbers[num1:num2+1]
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    num1, num2 = int(input())
    
    result = solution(numbers, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. 리스트의 슬라이싱을 사용하여 num1부터 num2+1까지 슬라이싱해준다.(마지막 인덱스의 원소를 포함시키기 위해 +1 을 해줌.)

***

### Q23(피자 나눠 먹기 (3))
```Python
def solution(slices, n):
    answer = 0
    
    if (n % slices == 0):
        answer = n / slices
    else:
        answer = int(n / slices + 1)
    
    return answer

if __name__ == "__main__":
    slices, n = int(input())
    
    result = solution(slices, n)
    print(result)
```
**주요 개념 및 로직**
1. 사람 수 n을 조각 slices로 나눈 나머지가 0이라면 딱 나눠떨어지는 것이므로, n을 slices로 나눈 몫을 answer에 할당하고,
2. 나머지가 0이 아니라면 n을 slices로 나눈 몫에 1을 더한 값을 int로 형변환하여 answer에 할당한다.

***

### Q24(점의 위치 구하기)
```Python
def solution(dot):
    answer = 0
    
    if (dot[0] > 0 and dot[1] > 0):
        answer = 1
    elif (dot[0] > 0 and dot[1] < 0):
        answer = 4
    elif (dot[0] < 0 and dot[1] > 0):
        answer = 2
    elif (dot[0] < 0 and dot[1] < 0):
        answer = 3
    
    return answer

if __name__ == "__main__":
    dot = list(map(int, input()))
    
    result = solution(dot)
    print(result)
```
**주요 개념 및 로직**
1. dot[0] = x, dot[1] = y 좌표라고 생각하고 조건문을 적절하게 분기하여 answer에 1, 2, 3, 4 중 하나의 값을 할당한다.

***

### Q25(배열의 유사도)
```Python
def solution(s1, s2):
    answer = 0
    
    for val in s1:
        if (val in s2):
            answer += 1

    return answer

if __name__ == "__main__":
    s1, s2 = input()
    
    result = solution(s1, s2)
    print(result)
```
**주요 개념 및 로직**
1. s1 리스트에 있는 원소들을 val에 담아 for문을 돌리는데, val 원소가 s2에도 있으면 answer의 개수를 하나씩 올린다.
2. 또 다른 풀이: len(set(s1)&set(s2)) <- 이런식으로 집합의 교집합 연산을 이용해서 구할 수도 있다.

***

### Q26(순서쌍의 개수)
```Python
def solution(n):
    answer = 0
    # pair_list = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer += 1
            # pair = (i, n // i)
            # pair_list.append(pair)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. i는 1부터 n+1 까지 반복한다:
2. n을 i로 나누어 떨어지면, 해당 값은 순서쌍이 되므로 answer에 +1을 해준다.
3. 주석 부분은 순서쌍을 튜플로 저장하는 부분. (문제에서는 필요없음.)

***

### Q27(n의 배수 고르기)
```Python
def solution(n, numlist):
    answer = []
    
    for num in numlist:
        if (num % n == 0):
            answer.append(num)
            
    # answer = [i for i in numlist if i%n==0]
            
    return answer

if __name__ == "__main__":
    n = int(input())
    numlist = list(map(int, input()))
    
    result = solution(n, numlist)
    print(result)
```
**주요 개념 및 로직**
1. numlist에 있는 원소들을 num에 담아 num을 n으로 나눴을 때 나머지가 0인(n의 배수인) 원소들만 answer 리스트에 붙인다.
2. 두 번째 방법은 리스트 컴프리헨션.

***

### Q28(배열 원소의 길이)
```Python
def solution(strlist):
    answer = []
    answer = [len(i) for i in strlist]
    
    # for i in strlist:
        # answer.append(len(i))
    
    return answer

if __name__ == "__main__":
    strlist = input()
    
    result = solution(strlist)
    print(result)
```
**주요 개념 및 로직**
1. strlist의 원소들 i의 길이들을 answer 리스트에 저장(리스트 컴프리헨션)
2. 다른 방법: for문을 이용한 방법

***

### Q29(아이스 아메리카노)
```Python
def solution(money):
    answer = []
    answer = [money // 5500, money % 5500]
    
    return answer

if __name__ == "__main__":
    money = int(input())
    
    result = solution(money)
    print(result)
```
**주요 개념 및 로직**
1. answer 배열은 money를 5500으로 나눈 정수 몫, money를 5500으로 나눈 나머지가 들어간다.

***

### Q30(문자열안에 문자열)
```Python
def solution(str1, str2):
    answer = 0
    
    if str2 in str1:
        answer = 1
    else:
        answer = 2
        
    # answer = 1 if str2 in str1 else 2
    
    return answer

if __name__ == "__main__":
    str1, str2 = input()
    
    result = solution(str1, str2)
    print(result)
```
**주요 개념 및 로직**
1. str2가 str1 안에 있으면 answer은 1, 없으면 2.
2. 두 번째 방법은 pythonic한 방법.

***

### Q31(문자 반복 출력하기)
```Python
def solution(my_string, n):
    answer = ''
    for i in range(len(my_string)):
        answer += my_string[i] * n
    return answer

if __name__ == "__main__":
    my_string = input()
    n = int(input())
    
    result = solution(my_string, n)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌려서 my_string의 한 글자씩 n을 곱하여 answer에 더한다.

***

### Q32(제곱수 판별하기)
```Python
def solution(n):
    answer = 0
    k = n ** 0.5
    answer = 1 if k % 1 == 0 else 2
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n에 2/1 제곱을 한 수를 k라 하고, k를 1로 나눈 나머지가 0, 즉 정수일 때 answer에 1을 할당하고, 아니면 2를 할당한다.

***

### Q33(특정 문자 제거하기)
```Python
def solution(my_string, letter):
    answer = ''
    
    for i in range(len(my_string)):
        if (my_string[i] != letter):
            answer += my_string[i]
            
    return answer

if __name__ == "__main__":
    my_string = input()
    letter = input()
    
    result = solution(my_string, letter)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌리는데, my_string의 문자가 letter와 같지 않은 것만 answer에 더한다.

***

### Q34(모음 제거)
```Python
def solution(my_string):
    answer = ''
    vowel_list = ['a', 'e', 'i', 'o', 'u']
    
    for i in range(len(my_string)):
        if (my_string[i] not in vowel_list):
            answer += my_string[i]

    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 모음 리스트 vowel_list에 a, e, i, o, u를 넣어준다.
2. my_string의 길이만큼 for문을 돌려서 my_string의 문자가 vowel_list에 있지 않은 문자(자음)만 answer에 더한다.

***

### Q35(짝수 홀수 개수)
```Python
def solution(num_list):
    answer = []
    odd_count, even_count = 0, 0

    for num in num_list:
        if (num % 2 == 0):
            even_count += 1
        else:
            odd_count += 1
            
    answer.append(even_count)
    answer.append(odd_count)

    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 홀수, 짝수의 개수를 세는 변수를 0으로 초기화하고, num_list에 있는 원소들을 하나씩 순회하며 원소를 2로 나눈 나머지가 0(짝수)일때는 짝수 카운터에 1을, 홀수일때는 홀수 카운터에 1을 더한다.
2. 마지막에 answer 리스트에 짝수 카운터, 홀수 카운터의 값을 각각 붙여서 마무리한다.

***

### Q36(중복된 숫자 개수)
```Python
def solution(array, n):
    answer = 0
    
    answer = array.count(n)
    
    # for num in array:
    #     if (num == n):
    #         answer += 1
            
    return answer

if __name__ == "__main__":
    array = list(map(int , input()))
    n = int(input())
    
    result = solution(array, n)
    print(result)
```
**주요 개념 및 로직**
1. count()로 원소의 개수를 세는 방법이 있고, for문으로 해당 원소를 세는 방법이 있다.

***

### Q37(배열 두 배 만들기)
```Python
def solution(numbers):
    answer = []
    answer = [2 * i for i in numbers] # numbers에 있는 원소를 i라 할 때, 2 * i한 값들을 answer에 저장하라.
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers에 있는 원소를 i라 할 때, 2 * i 한 값들을 answer 리스트에 저장한다.

***

### Q38(중앙값 구하기)
```Python
def solution(array):
    answer = 0
    array = sorted(array)
    mid = len(array) // 2
    
    if len(array) % 2 == 1: # 홀수개
        answer = array[mid]
    else: # 짝수개
        answer = (array[mid-1] + array[mid]) / 2
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. array를 오름차순 정렬하고, mid 변수(array의 길이 / 2)를 선언한다.
2. array의 길이를 2로 나눈 나머지가 1이면 리스트의 개수가 홀수개이므로, 아까 선언한 mid가 중앙값이 된다.
3. 나머지가 0이면 리스트의 개수가 짝수개이므로, mid-1, mid를 더해 2로 나눈 값이 중앙값이 된다.

***

### Q39(짝수는 싫어요)
```Python
def solution(n):
    answer = []
    
    for i in range(n+1):
        if (i % 2 == 1):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0부터 n+1까지 for문을 돌려 i를 2로 나눈 나머지가 1(홀수)일 때만 answer에 붙인다.

***

### Q40(옷 가게 할인 받기)
```Python
def solution(price):
    answer = 0
    
    if (price >= 100000 and price < 300000):
        answer = price * 0.95
    elif (price >= 300000 and price < 500000):
        answer = price * 0.9
    elif (price >= 500000):
        answer = price * 0.8
    else:
        answer = price
    
    return int(answer)

if __name__ == "__main__":
    price = int(input())
    
    result = solution(price)
    print(result)
```
**주요 개념 및 로직**
1. price에 따라 조건문을 적절히 분기해 5%는 0.95, 10%는 0.9, 20%는 0.8을 곱하고, answer는 정수형으로 반환한다.

***

### Q41(직각삼각형 출력하기)
```Python
if __name__ == "__main__":
    n = int(input())
    for i in range(1, n+1):
        print("*" * i)
```
**주요 개념 및 로직**
1. for문의 범위는 1부터 n+1까지주고, 줄 마다 *의 개수를 i와 곱하여 출력하면 된다.

***

### Q42(개미 군단)
```Python
def solution(hp):
    answer = 0
    
    ant1 = hp // 5 # 장군개미
    ant2 = hp % 5 // 3 # 병정개미
    ant3 = hp % 5 % 3 // 1 # 일개미
    
    answer += ant1 + ant2 + ant3
    
    return answer

if __name__ == "__main__":
    hp = int(input())
    
    result = solution(hp)
    print(result)
```
**주요 개념 및 로직**
1. ant1을 장군개미의 수, ant2를 병정개미의 수, ant3을 일개미의 수로 나타내면 다음과 같다.
2. 각자 구한 최소 개체의 수를 다 더하여 answer에 더하면 최소한의 병력이 산출된다.

***

### Q43(가위 바위 보)
```Python
def solution(rsp):
    answer = ''
    rsp_list = ['2', '0', '5'] # 순서대로 가위, 바위, 보

    for i in range(len(rsp)):
        idx = rsp_list.index(str(rsp[i]))
        answer += rsp_list[(idx + 1) % 3]
            
    return answer

if __name__ == "__main__":
    rsp = input()
    
    result = solution(rsp)
    print(result)
```
**주요 개념 및 로직**
1. 가위바위보 리스트 rsp_list에 2, 0, 5를 순서대로 담아준다.
2. 받은 문자열 rsp의 길이만큼 for문을 돌려 현재 인덱스에 해당하는 원소를 idx로 담아준다.
3. answer에는 다음 인덱스(ex) 2 -> 0, 0 -> 5, 5 -> 2)에 해당하는 원소를 담아준다.

***

### Q44(주사위의 개수)
```Python
def solution(box, n):
    answer = 1
    
    for val in box:
        answer *= (val // n)

    return answer

if __name__ == "__main__":
    box = list(map(int, input()))
    n = int(input())
    
    result = solution(box, n)
    print(result)
```
**주요 개념 및 로직**
1. box에 있는 가로, 세로, 높이를 각각 val로 담아, val을 n으로 나눈 정수 몫을 다 곱하여 answer에 저장한다. (상자에 들어갈 수 있는 주사위의 최대 개수 나옴)
2. 단순히 가로 * 세로 * 높이를 한 부피에서는 남는 공간을 고려하지 못해 정확한 값이 나오지 않음.

***

### Q45(문자열 정렬하기 (1))
```Python
def solution(my_string):
    answer = []
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer.append(int(val))
            
    return sorted(answer)

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 문자도 0부터 9까지 정렬가능하므로 my_string의 원소 val이 0부터 9 사이에 있을 경우, answer 리스트에 int로 형변환하여 붙이고, 정렬된 answer 리스트를 반환한다.

***

### Q46(숨어있는 숫자의 덧셈 (1))
```Python
def solution(my_string):
    answer = 0
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer += int(val)
            
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 동일하게 숫자로 된 원소들을 int로 형변환하여 answer에 다 더한다.

***

### Q47(최댓값 만들기 (2))
```Python
def solution(numbers):
    numbers = sorted(numbers)
    
    cand1 = numbers[0] * numbers[1]
    cand2 = numbers[-1] * numbers[-2]
    answer = max(cand1, cand2)
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input().split()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers 리스트를 정렬하고, 음수와 음수를 곱한 최댓값과 양수와 양수를 곱한 최댓값을 cand1, cand2에 저장해서 둘 중 더 큰 것을 answer에 할당한다.

***

### Q48(암호 해독)
```Python
def solution(cipher, code):
    answer = ''
    
    for i in range(code-1, len(cipher), code):
        answer += cipher[i]
    
    return answer

if __name__ == "__main__":
    cipher = input()
    code = int(input())
    
    result = solution(cipher, code)
    print(result)
```
**주요 개념 및 로직**
1. code-1부터 cipher의 길이까지 step을 code크기로 cipher의 원소들을 answer에 붙인다.

***

### Q49(대문자와 소문자)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    
    for i in range(len(my_string)):
        if (my_string[i].islower()):
            my_string[i] = my_string[i].upper()
        elif (my_string[i].isupper()):
            my_string[i] = my_string[i].lower()
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트화 해주고, for문을 돌려서 my_string의 원소가 소문자인지, 대문자인지 판별 후, 소문자는 대문자로, 대문자는 소문자로 바꿔주는 작업을 실시한 후, 다시 string화 해준다.

***

### Q50(인덱스 바꾸기)
```Python
def solution(my_string, num1, num2):
    answer = ''
    my_string = list(my_string)
    
    temp = my_string[num1]
    my_string[num1] = my_string[num2] # 불변 객체라 스트링을 바로 바꿀 순 없음.
    my_string[num2] = temp # 마찬가지.
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    num1, num2 = int(input())
    
    result = solution(my_string, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트로 바꿔주고, temp에 num1 인덱스에 해당한 my_string 원소를 담아준다.
2. 그 후, num2 인덱스에 있던 원소를 num1 인덱스의 원소로 바꾸고,
3. num2 인덱스에 있던 원소를 temp로 바꾼다.
4. 마지막엔 다시 string화 시키기.

***

### Q51(약수 구하기)
```Python
def solution(n):
    answer = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 1부터 n+1까지 n을 i로 나눈 나머지가 0인 값(i가 n의 약수)만 answer에 붙인다.

***

### Q52(가장 큰 수 찾기)
```Python
def solution(array):
    answer = []
    answer = [max(array), array.index(max(array))]
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. answer에 array에서 가장 큰 값, 그 값의 인덱스를 담는다.

***

### Q53(문자열 정렬하기(2))
```Python
def solution(my_string):
    answer = ''
    my_string = my_string.lower()
        
    answer = ''.join(sorted(my_string))
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 전부 소문자로 바꾼 것을 정렬하여 스트링으로 바꿔주면 된다.

***

### Q54(숫자 찾기)
```Python
def solution(num, k):
    answer = 0
    num = str(num)
    k = str(k)
    
    if (k in num):
        answer = num.index(k) + 1
    else:
        answer = -1
              
    return answer

if __name__ == "__main__":
    num, k = int(input())
    
    result = solution(num, k)
    print(result)
```
**주요 개념 및 로직**
1. num과 k를 스트링을 바꿔주고, k가 num에 있으면 그 인덱스 + 1을 answer에, 없으면 -1을 answer에 담는다.

***

### Q55(피자 나눠 먹기(2))
```Python
def solution(n):
    answer = 0
    i = 1
    
    while(1):
        if ((6 * i) % n == 0):
            break
        i += 1
        
    answer = i
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 6판 * i를 n명 만큼 나눈 나머지가 0이 되는 로직을 통해 n명이 각자 똑같이 먹을 수 있는 최소 판을 구할 수 있다.
2. 초기에 i는 1부터 시작해 점점 증가하다가 n을 나눈 나머지가 0이 되는 순간 break를 통해 while문을 탈출한다. 그 i가 answer이다.

***

### Q56(외계행성의 나이)
```Python
def solution(age):
    answer = ''
    age = str(age)
    mapping = "abcdefghij"
    
    for num in age:
        answer += mapping[int(num)]
        
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. age를 string화 해주고, mapping 문자열에 a~j까지 둔다.
2. age에 있는 숫자들을 돌며 그 숫자를 int로 형변환한 것이 mapping의 인덱스로 들어가, 매핑된 값을 answer에 이어붙인다.

***

### Q57(배열 회전시키기)
```Python
def solution(numbers, direction):
    answer = []
    
    if (direction == "right"):
        for i in range(len(numbers)):
            answer.append(numbers[(i - 1) % len(numbers)])
    elif (direction == "left"):
        for i in range(len(numbers)):
            answer.append(numbers[(i + 1) % len(numbers)])
            
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    direction = input()
    
    result = solution(numbers, direction)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 answer에 direction이 left이면 numbers 리스트의 길이만큼 for문을 돌려 (i - 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (왼쪽으로 회전)
2. direction이 right이면 numbers 리스트의 길이만큼 for문을 돌려 (i + 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (오른쪽으로 회전)

***

### Q58(369게임)
```Python
def solution(order):
    answer = 0
    order = str(order)
    
    for num in order:
        if (int(num) != 0 and int(num) % 3 == 0):
            answer += 1
    
    return answer

if __name__ == "__main__":
    order = int(input())
    
    result = solution(order)
    print(result)
```
**주요 개념 및 로직**
1. order를 스트링으로 바꿔주고, int로 형변환된 각 숫자마다 0이 아니고, 3의 배수(3, 6, 9)일 때, answer에 1을 더한다.

***

### Q59(합성수 찾기)
```Python
def solution(n):
    answer = 0
    new_list = []
    
    for i in range(1, n+1):
        count = 0
        for j in range(1, i+1):
            if (i % j == 0):
                count += 1
        new_list.append(count)
    
    answer = len([x for x in new_list if x >= 3])

    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 합성수란 약수가 1과 자기 자신을 포함하여 개수가 3개 이상인 수를 말하므로, 우선 n 이하의 합성수의 개수를 구하기 위해 1부터 n까지의 수의 합성수를 담을 리스트 new_list를 선언,
2. for문을 돌려 count의 개수를 매번 0으로 초기화, 두번째 for문에서는 1부터 해당 원소(i)까지 해당 원소를 j(1~i)로 나눈 값이 0이되는 값이 있을 때 count의 개수를 1 증가시킨다.
3. 각 i의 for문이 끝나면 계산된 카운트를 new_list에 붙인다.
4. 모든 for문이 끝나고 나면 new_list에는 n이하의 정수들의 합성수들의 개수가 담겨있게 되므로, len()과 리스트 컴프리헨션을 통해 count가 3 이상인 것들만 골라 합성수의 개수를 찾아낸다.

***

### Q60(중복된 문자 제거)
```Python
def solution(my_string):
    answer = ''
    lst = []
    for val in my_string:
        if (val not in lst):
            lst.append(val)
            
    answer = ''.join(lst)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 문자들을 val이라고 했을 때, val이 lst에 없으면 val을 lst에 추가한다.
2. 마지막에 리스트 형태를 string으로 answer에 저장하고, 반환한다.

***

### Q61(모스부호 (1))
```Python
def solution(letter):
    answer = ''
    letter = list(letter.split(' '))
    morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
    }
    for i in range(len(letter)):
        answer += morse[letter[i]]
        
    return answer

if __name__ == "__main__":
    letter = input()
    
    result = solution(letter)
    print(result)
```
**주요 개념 및 로직**
1. letter을 받고, 공백으로 분리해 리스트로 만든다.
2. morse 딕셔너리는 문제에서 주어진 그대로이다.
3. for문을 letter 리스트 길이만큼 돌려 각 원소(키)를 주면 그에 맞는 문자가 반환되어 answer에 담긴다.

***

### Q62(2차원으로 만들기)
```Python
def solution(num_list, n):
    answer = []
    
    row = len(num_list) // n
    col = n
    k = 0
    
    for i in range(row):
        answer.append([])
        for j in range(col):
            answer[i].append(num_list[k])
            k += 1
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 행렬에서 사용될 row, col, k=0을 선언해주고,
2. 행 만큼 for문을 반복하여, 각 행마다 빈 리스트([])를 붙여주고, 열 만큼 for문을 반복하여, num_list의 원소들을 계속 가져와 answer의 각 행의 빈 리스트에 붙여넣는다.

***

### Q63(A로 B 만들기)
```Python
def solution(before, after):
    answer = 0
    answer = 1 if (sorted(before) == sorted(after)) else 0

    return answer

if __name__ == "__main__":
    before = input()
    after = input()
    
    result = solution(before, after)
    print(result)
```
**주요 개념 및 로직**
1. before 문장을 어떻게 조합해도 after와 같아지려면, 결국 구성하고 있는 문자의 개수가 같아야 한다.
2. 그렇기에, before 문장과 after 문장을 sorted()로 비교한 결과가 같으면 1, 같지 않으면 조합 불가능이므로 0이다.

***

### Q64(k의 개수)
```Python
def solution(i, j, k):
    answer = 0
    k = str(k)
    
    for num in range(i, j+1):
        answer += str(num).count(k)

    return answer

if __name__ == "__main__":
    i, j, k = int(input().split(' '))
    
    result = solution(i, j, k)
    print(result)
```
**주요 개념 및 로직**
1. 문자열로 비교하기 위해 k를 스트링으로 바꿔주고, i부터 j까지의 숫자도 string num으로 비교한다.
2. answer에는 num에 k가 들어있는 개수를 더하며 저장한다.

***

### Q65(한 번만 등장한 문자)
```Python
def solution(s):
    answer = ''
    answer = [x for x in set(s) if s.count(x) == 1]    
    answer = sorted(answer)
    
    return ''.join(answer)

if __name__ == "__main__":
    s = input()
    
    result = solution(s)
    print(result)
```
**주요 개념 및 로직**
1. 집합 s(s = {s에서 중복이 제거된 각 문자들})에서 문자들을 x라 하여 리스트에 저장한다.
2. 조건은 스트링 s에서 x(집합의 원소들)을 카운트한 것이 1인 원소들만 리스트에 저장한다.
3. answer은 리스트이므로, 반환할 때는 ''.join()을 사용해 스트링으로 바꿔준 뒤 반환한다.

***

### Q66(숨어있는 숫자의 덧셈 (2))
```Python
def solution(my_string):
    answer = 0
    current_char = ''
    
    for val in my_string:
        if val >= '0' and val <= '9':
            current_char += val
        else:
            if current_char:
                answer += int(current_char)
                current_char = ''
                
    if current_char:
        answer += int(current_char)
        
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 합계를 담을 answer, 현재 문자를 담을 current_char 변수를 선언하고,
2. my_string의 문자 하나씩 순회하며, val이 숫자인 경우, current_char에 담는다.
3. 그러다가 문자를 만난 경우, current_char에 있는 문자를 정수로 바꾼다음, answer에 더한다. currnet_char는 다음 숫자를 더하기 위해 빈 문자열로 초기화한다.
4. 모든 작업이 끝나고, 마지막이 숫자로 끝난 경우에 대비해, current_char에 남아있는 문자들을 정수로 바꾸어 answer에 더한다.

***

### Q67(7의 개수)
```Python
def solution(array):
    answer = 0
    array = ''.join(list(map(str, array)))
    answer = array.count('7')
    
    return answer

if __name__ == "__main__":
    array = input()
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. 정수형 리스트를 스트링 리스트로 바꾸고, string화 시켜주고,
2. 그 string에서 '7'의 개수를 찾아 answer에 저장한다.

***

### Q68(진료 순서 정하기)
```Python
def solution(emergency):
    answer = []
    
    sorted_emergency = sorted(emergency, reverse=True)
    answer = [sorted_emergency.index(x) + 1 for x in emergency]
    
    return answer

if __name__ == "__main__":
    emergency = list(map(int, input()))
    
    result = solution(emergency)
    print(result)
```
**주요 개념 및 로직**
1. 먼저 큰 숫자가 진료 우선순위가 높으므로, emergency 리스트를 내림차순으로 정렬한 sorted_emergency를 만들어준다.
2. answer 리스트에는 emergency에 있는 원소가 순서대로 sorted_emergency 리스트에서 어떤 인덱스를 가지는지 뽑아와 리스트에 들어간다.

***

### Q69(팩토리얼)
```Python
def solution(n):
    fact = 1
    i = 1
    while (fact <= n):
        i += 1
        fact *= i
        
    answer = i - 1
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. factorial 값을 담을 변수 fact와 곱셈 변수 i를 1로 선언하고, fact 값이 n보다 작은 동안 while 문을 돌린다:
2. i에 1을 더하고, fact에 계속 곱해나간다.
3. 그러다가 fact 값이 어느순간 n을 넘게 되면 whlie문을 탈출하고, 넘게 된 값 이전의 값을 answer에 저장해야 하므로 i에 1을 빼서 저장한다.

***

### Q70(가까운 수)
```Python
def solution(array, n):    
    array.sort()
    temp = []

    for i in array :
        temp.append(abs(n-i))

    return array[temp.index(min(temp))]

if __name__ == "__main__":
    array = list(map(int, input()))
    n = int(input())
    
    result = solution(array, n)
    print(result)
```
**주요 개념 및 로직**
1. array의 원소 중 n과 i의 차가 같은 것이 있을 수 있으므로 정렬을 시킨다.
2. 빈 리스트 temp를 만들고, array의 원소를 하나씩 순회하며 temp에 n과 i의 차의 절댓값을 넣는다.
3. 그 중, 가장 작은 차를 갖는 원소의 인덱스를 array의 인덱스와 동일치시켜 그 값을 answer로 반환한다.

***

### Q71(컨트롤 제트)
```Python
def solution(s):
    answer = 0
    s = list(map(str, s.split(' ')))
    
    for i in range(len(s)):
        if (s[i] == 'Z'):
            answer -= int(s[i-1])
        else:
            answer += int(s[i])
            
    return answer

if __name__ == "__main__":
    s = input()
    
    result = solution(s)
    print(result)
```
**주요 개념 및 로직**
1. s 스트링을 공백으로 분리해 리스트화 시키고,
2. s의 길이만큼 for문을 돌려, 만약 현재 원소가 Z이면 그 전 원소의 값을 정수화시켜 answer에 저장하고,
3. Z가 아니면 현재 원소의 값을 정수화시켜 answer에 저장한다.

***

### Q72(잘라서 배열로 저장하기)
```Python
def solution(my_str, n):
    answer = []
    
    for i in range(0, len(my_str), n):
        answer.append(my_str[i:i+n])
        
    return answer

if __name__ == "__main__":
    my_str = input()
    n = int(input())
    
    result = solution(my_str, n)
    print(result)
```
**주요 개념 및 로직**
1. 0부터 my_str의 길이까지의 범위에 step은 n만큼 주고 for문을 돌린다:
2. my_str[i:i+n]까지 슬라이싱하여 answer에 더한다.

***

### Q73(소인수분해)
```Python
def solution(n):
    answer = []
    temp = []
    k = 2
    
    while (k <= n):
        if (n % k == 0):
            temp.append(k)
            n /= k
        else:
            k += 1
            
    for x in temp:
        if x not in answer:
            answer.append(x)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. k가 n보다 작거나 같을 때까지 while문으로 반복한다:
2. 만약 n이 k로 나누어 떨어질 때, k를 temp 리스트에 넣고, n은 k로 나눈 값으로 바꾼다.
3. 나누어 떨어지지 않으면, k의 값을 1 증가시킨다.
4. temp 리스트에는 소인수들이 담겨있지만, 중복된 값들도 있을 수 있으므로 중복제거를 한다.
5. temp의 원소들을 x로 하여, answer 리스트에 x가 없을때만 추가한다.

***

### Q74(문자열 계산하기)
```Python
def solution(my_string):
    my_string = my_string.split(' ')
    answer = int(my_string[0])
    
    # 연산자 순회
    for i in range(1, len(my_string), 2):
        op = my_string[i]
        num = int(my_string[i+1])
        
        if (op == '+'):
            answer += num
        elif (op == '-'):
            answer -= num

    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string 문장의 피연산자와 연산자를 구분하기 위해 공백을 기준으로 분리해 리스트로 만든다.
2. my_string의 첫번째 피연산자값을 answer에 정수형으로 변환해 담는다.
3. for문으로 첫번째 연산자부터 끝 연산자까지 순회한다:
4. 해당 연산자 값을 op에 담고, 계산할 피연산자 값을 num에 담는다.
5. 만약 해당 연산자가 '+'이면 num을 answer에 더하고, '-'이면 num을 answer에 뺀다.

***

### Q75(공 던지기)
```Python
def solution(numbers, k):
    answer = 0
    i = 0
    
    for _ in range(1, k+1):
        idx = numbers.index(numbers[i])
        i = (i + 2) % len(numbers)

    # 또는
    # for _ in range(1, k):
        # i = (i + 2) % len(numbers)

    # answer = numbers[i]

    # 또는
    # answer = numbers[(2 * (k - 1)) % len(numbers)]
    
    answer = numbers[idx]
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    k = int(input())
    
    result = solution(numbers, k)
    print(result)
```
**주요 개념 및 로직**
1. i의 초기값은 0, for문을 k번 반복한다:
2. idx에는 numbers[0]의 인덱스부터 i가 2개씩 뛰어넘는 numbers의 인덱스를 저장한다.
3. 그때의 numbers[idx] 값이 answer이다.
4. 또는 idx를 쓰지 않고 k번 만큼만 반복하여 i값에 바로 해당 인덱스를 담아준다.
5. 또는 (2 * (k - 1)) % len(numbers)로 간략화 시킨 인덱스를 numbers에서 바로 추출할 수도 있다.

***

### Q76(이진수 더하기)
```Python
def solution(bin1, bin2):
    answer = ''
    
    num1 = int(bin1, 2)
    num2 = int(bin2, 2)
    
    answer = bin(num1 + num2)[2:]
    return answer

if __name__ == "__main__":
    bin1 = input()
    bin2 = input()
    
    result = solution(bin1, bin2)
    print(result)
```
**주요 개념 및 로직**
1. num1과 num2에 이진수 bin1과 bin2를 정수로 변환한 값을 각각 담고,
2. answer에는 num1과 num2를 더한 값을 다시 이진수로 변환시켜서 앞의 '0b'를 제거한 값을 담는다.

***

### Q77(영어가 싫어요)
```Python
def solution(numbers):
    answer = ''
    idx = 0
    number_list = {"one":1, "two":2, "three":3, "four":4, "five":5, "six":6, "seven":7, "eight":8, "nine":9, "zero":0}
    
    while(idx < len(numbers)):
        for word, digit in number_list.items():
            if (numbers[idx:].startswith(word)):
                answer += str(digit)
                idx += len(word)
                break        
            
    return int(answer)

if __name__ == "__main__":
    numbers = input()
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. number_list 딕셔너리를 만들어놓고, idx 값에 0을 주고 idx가 numbers 길이보다 작은동안 while문을 돌린다:
2. number_list에 있는 item들(word, digit) 값을 순회한다:
3. numbers의 idx로 시작하는 단어가 'one', 'two', ... 'zero'이면 그 에 해당하는 value 값(digit)을 answer에 스트링 형태로 넣고, 그 key(word)값의 길이만큼 idx를 더한다.
4. 단어를 찾았으니 break로 다음 구문을 찾는다. 최종적으로 다 변환한 뒤에는 다시 정수형으로 answer를 반환한다.

***

### Q78(구슬을 나누는 경우의 수)
```Python
def solution(balls, share):
    answer = 0
    cal_balls = 1
    cal_share = 1
    
    for i in range(balls, balls-share, -1):
        cal_balls *= i
    for i in range(1, share+1):
        cal_share *= i
    
    answer = cal_balls // cal_share
        
    return answer

if __name__ == "__main__":
    balls, share = map(int, input().split())
    
    result = solution(balls, share)
    print(result)
```
**주요 개념 및 로직**
1. 계산된 항목들을 나타내는 cal_balls, cal_share을 1로 선언하고
2. balls는 balls부터 balls-share까지 1씩 차감하며 for문을 돌려서 그 i 값을 cal_balls에 곱하고, (ex) balls = 5, share = 2 / cal_balls = 5 * 4)
3. share는 1부터 share+1까지 1씩 더하여 for문을 돌려서 그 i 값을 cal_share에 곱한다. (ex) balls = 5, share = 2 / cal_share = 1 * 2)
4. answer에는 cal_balls를 cal_share로 나눈 정수 몫을 반환한다.

***

### Q79(삼각형의 완성조건 (2))
```Python
def solution(sides):
    answer = 0
    
    # case1: 가장 긴 변이 sides 안에 있는 경우
    max_side = max(sides)
    other_side = min(sides)
    answer_side = max_side - other_side + 1
    case1_lst = []
    while (answer_side <= max_side):
        case1_lst.append(answer_side)
        answer_side += 1
    
    # case2: 가장 긴 변이 sides에 없는 경우
    side1 = max(sides)
    side2 = min(sides)
    answer_side = side1 + side2 - 1
    case2_lst = []
    while (answer_side > side1):
        case2_lst.append(answer_side)
        answer_side -= 1
        
    answer = len(case1_lst) + len(case2_lst)
    
    # 또는
    # answer = (sum(sides) - max(sides)) + (min(sides) - 1)
    
    return answer

if __name__ == "__main__":
    sides = list(map(int, input()))
    
    result = solution(sides)
    print(result)
```
**주요 개념 및 로직**
1. case1은 가장 긴 변이 sides 안에 있는 경우로 가장 긴 변과 나머지 변을 변수로 담아, 나머지가 될 수 있는 변 중에 가장 작은 변을 일단 answer_side에 담고, while문으로 1씩 증가하며 max_side보다 커질 때, 중단하는 방법
2. case2는 가장 긴 변이 sides 안에 없는 경우로, 나머지 두 변을 side1, side2에 담고, 가장 긴 변이 될 수 있는 변 중에 가장 큰 변을 일단 answer_side에 담고, while문으로 1씩 감소하며 side1(max side)보다 작아질 때, 중단하는 방법
3. case1_lst와 case2_lst의 개수를 더해 answer에 반환한다.
4. 간단하게 푸는 경우는 나머지 변이 될 수 있는 개수를 구하기 위해 두 변을 리스트에 넣고, 작은 변과 큰 변으로 계산하는 변형된 공식을 사용할 수 있다.
5. 핵심은 **|a-b| < c < a+b**이고, 가능한 값의 개수는 항상 **(a+b-1) - (|a-b|+1) +1**와 동일하다.

***

### Q80(캐릭터의 좌표)
```Python
def solution(keyinput, board):
    answer = []
    x, y = 0, 0
    wall_x, wall_y = board[0] // 2, board[1] // 2
    
    for action in keyinput:
        if (action == "left"):
            if (x - 1 < -wall_x):
                continue
            else:
                x -= 1
        elif (action == "right"):
            if (x + 1 > wall_x):
                continue
            else:
                x += 1
        elif (action == "up"):
            if (y + 1 > wall_y):
                continue
            else:
                y += 1
        elif (action == "down"):
            if (y - 1 < -wall_y):
                continue
            else:
                y -= 1
                
    answer = [x, y]
    return answer

if __name__ == "__main__":
    keyinput = input()
    board = input()
    
    result = solution(keyinput, board)
    print(result)
```
**주요 개념 및 로직**
1. 초기 x, y값을 0, 0을 주고, 경계 좌표 wall_x, wall_y를 board의 x, y 값을 2로 나눈 정수 몫으로 준다.
2. keyinput의 내용을 action으로 받아 for문을 돌린다:
3. action이 left일 때, 해당 입력에서 한 칸 더 왼쪽으로 갔을 때 경계좌표를 초과하면 continue, 아니면 x좌표에서 1을 뺀다.
4. action이 right일 때, 해당 입력에서 한 칸 더 오른쪽으로 갔을 때 경계좌표를 초과하면 continue, 아니면 x좌표에서 1을 더한다.
5. action이 up일 때, 해당 입력에서 한 칸 더 위로 갔을 때 경계좌표를 초과하면 continue, 아니면 y좌표에서 1을 더한다.
6. action이 down일 때, 해당 입력에서 한 칸 더 아래로 갔을 때 경계좌표를 초과하면 continue, 아니면 y좌표에서 1을 뺀다.
7. 최종적으로 action이 끝났을 때의 x, y 값을 answer에 담는다.

***

### Q81(
