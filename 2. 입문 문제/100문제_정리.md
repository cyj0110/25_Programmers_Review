# 입문 문제 정리

[Python] 

모든 문제 번호는 '정답률 높은 문제순' 정렬 되어 있는 문제들의 번호임.

실제 프로그래머스 사이트에서 문제의 순서는 추후 변경될 수 있으니 참고바람.

## 출력

### Q1(나머지 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 % num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '%' 연산자를 쓰면 나머지를 구할 수 있다.

***

### Q2(두 수의 차 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 - num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '-' 연산자를 쓰면 두 수의 차를 구할 수 있다.
  
***

### Q3(숫자 비교하기)
```Python
def solution(num1, num2):
    answer = 0
    if (num1 == num2):
        answer = 1
    else:
        answer = -1
        
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. if 문으로 num1과 num2가 같은지 비교한다.

***

### Q4(나이 출력)
```Python
def solution(age):
    answer = 0
    answer = 2022 - age + 1
    
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. 2022년 기준이므로 2022에서 age를 빼고 1을 더한다. (제한사항은 만 나이가 아님.)

***

### Q5(두 수의 나눗셈)
```Python
def solution(num1, num2):
    answer = 0
    answer = int((num1 / num2) * 1000)
    
    return answer

if __name__ == "__name__":
    num1, num2 = int(input())
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. (num1 / num2) * 1000 하여 int로 형변환하면 정수 부분이 추출된다.

***

### Q6(몫 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = int(num1 / num2)
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. num1을 num2로 나누기 위해 '/' 연산자를 사용하고, int로 형변환해준다.

***

### Q7(두 수의 곱 구하기)
```Python
def solution(num1, num2):
    answer = 0
    answer = num1 * num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '*' 연산자를 사용하면 두 수의 곱을 구할 수 있다.
  
***

### Q8(두 수의 합 구하기)
```Python
def solution(num1, num2):
    answer = -1
    answer = num1 + num2
    
    return answer

if __name__ == "__main__":
    num1, num2 = input()
    
    result = solution(num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. '+' 연산자를 사용하면 두 수의 합을 구할 수 있다.
  
***

### Q9(각도기)
```Python
def solution(angle):
    answer = 0
    
    if (angle > 0 and angle < 90):
        answer = 1
    elif (angle == 90):
        answer = 2
    elif (angle > 90 and angle < 180):
        answer = 3
    elif (angle == 180):
        answer = 4
    else:
        answer = -1

    return answer

if __name__ == "__main__":
    angle = int(input())
    
    result = solution(angle)
    print(result)
```
**주요 개념 및 로직**
1. 조건에 따라 if, elif, else로 적절히 분기하여 answer에 1~4의 값을 넣으면 된다.

***

### Q10(양꼬치)
```Python
def solution(n, k):
    answer = 0
    
    if (n < 10):
        answer = (n * 12000) + (k * 2000)
    else:
        m = int(n / 10)
        answer = (n * 12000) + ((k - m) * 2000)
        
    return answer

if __name__ == "__main__":
    n, k = int(input())
    
    result = solution(n, k)
    print(result)
```
**주요 개념 및 로직**
1. 양꼬치를 10인분 먹으면 음료수 하나를 서비스로 준다고 했으므로,
2. 양꼬치를 10인분 이상 먹었을 때와, 먹지 않았을 때로 나누고, 10인분 미만으로 먹었으면 서비스는 없으므로 먹은 인분만큼 가격을 곱하여 answer에 할당한다.
3. 양꼬치를 10인분 이상 먹었을 때는 서비스 개수를 담을 변수 m에 n을 10으로 나눈 몫을 정수로 저장하고, 음료수 개수에서 서비스 개수(m)를 뺀 인분만큼 가격을 곱하여 answer에 할당한다. (양꼬치는 동일)

***

### Q11(짝수의 합)
```Python
def solution(n):
    answer = 0
    
    for i in range(0, n+1):
        if (i % 2 == 0):
            answer += i
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0~n까지 숫자 중에 짝수인것만 answer에 더한다.

***

### Q12(배열의 평균값)
```Python
def solution(numbers):
    answer = 0
    
    numbers = list(numbers)
    answer = sum(numbers) / len(numbers)
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. sum() 함수와 len() 함수를 이용해 리스트의 평균값을 계산한다.

***

### Q13(배열 뒤집기)
```Python
def solution(num_list):
    answer = []
    num_list.reverse()
    
    answer = num_list
    
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. num_list.reverse() 함수로 num_list의 원소들을 뒤집고, answer에 할당한다.
2. 참고: num_list[::-1]를 사용하는 방법도 있다.

***

### Q14(뒤집힌 문자열)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    my_string.reverse()
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. String을 리스트로 바꿔주고, reverse()를 이용해 뒤집어준 뒤, ''.join() 메소드로 다시 String으로 바꿔준다.
2. 참고: String도 my_string[::-1] 슬라이싱이 가능하다.

***

### Q15(편지)
```Python
def solution(message):
    answer = 0
    
    message = list(message)
    answer = len(message) * 2
    
    return answer

if __name__ == "__main__":
    message = input()
    
    result = solution(message)
    print(result)
```
**주요 개념 및 로직**
1. message String을 리스트로 바꿔주고, 리스트(message)의 길이에 2를 곱해준 것이 가로 길이이므로, answer에 할당한다.

***

### Q16(피자 나눠 먹기 (1))
```Python
def solution(n):
    answer = 0
    
    if (n % 7 != 0):
        answer = n // 7 + 1
    else:
        answer = n // 7
        
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 7로 나눈 나머지가 0이 아닐 때는 n을 7로 나눈 몫에 1을 더하여준 값을 answer에 할당하고,
2. n을 7로 나눈 나머지가 0일 때는 n을 7로 나눈 몫을 answer에 할당한다.

***

### Q17(세균 증식)
```Python
def solution(n, t):
    answer = 0    
    answer = n * pow(2, t)
    return answer

if __name__ == "__main__":
    n, t = int(input())
    
    result = solution(n, t)
    print(result)
```
**주요 개념 및 로직**
1. 처음 세균의 마리 수(n)에 한 시간에 2배로 증식한다고 하였으므로, 2^t(시간) 만큼을 곱해주면 된다. (pow 함수)

***

### Q18(최댓값 만들기(1))
```Python
def solution(numbers):
    answer = 0
    
    #1
    # num1 = max(numbers)
    # numbers.remove(num1)
    # num2 = max(numbers)
    
    # answer = num1 * num2
    
    #2
    numbers.sort()
    answer = numbers[-1] * numbers[-2]
    
    return answer

if __name__ == "__main__":
    numbers = map(int, input())
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. 첫 번째 방법: num1에 numbers의 최댓값을 넣고, 제거한다. 그 다음 최댓값을 num2에 넣고 두 값을 곱한 값을 answer에 할당한다.
2. 두 번째 방법: sort로 정렬시키고 맨 끝 원소와 맨 끝에서부터 두번째 원소를 곱해서 answer에 할당한다.

***

### Q19(자릿수 더하기)
```Python
def solution(n):
    answer = 0
    
    n = str(n)
    for i in range(len(n)):
        answer += int(n[i])
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n을 스트링으로 바꿔주고, n의 길이만큼 for문을 돌린다:
2. n의 인덱스 i에 해당하는 원소들을 정수형으로 형변환하고, answer에 계속 더해준다.

***

### Q20(머쓱이보다 키 큰 사람)
```Python
def solution(array, height):
    answer = 0
    
    for i in range(len(array)):
        if (height < array[i]):
            answer += 1
            
    return answer

if __name__ == "__main__":
    array = map(int, input())
    height = int(input())
    
    result = solution(array, height)
    print(result)
```
**주요 개념 및 로직**
1. array의 길이만큼 for문을 돌리는데, array의 원소가 height보다 큰 원소가 나타날 때, answer에 1을 더한다.(count 개념)

***

### Q21(삼각형의 완성조건 (1))
```Python
def solution(sides):
    answer = 0
    
    long = max(sides)
    sides.remove(long)
    if (sum(sides) > long):
        answer = 1
    else:
        answer = 2
    
    return answer

if __name__ == "__main__":
    sides = input()
    
    result = solution(sides)
    print(result)
```
**주요 개념 및 로직**
1. 가장 긴 변을 max()를 사용해 long 변수에 담아준다.
2. 그리고 long을 배열에서 제외해준 sides 배열의 원소의 합이 long보다 클 경우 삼각형의 완성 조건을 만족하므로 answer은 1, 아니면 2.

***

### Q22(배열 자르기)
```Python
def solution(numbers, num1, num2):
    answer = []
    answer = numbers[num1:num2+1]
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    num1, num2 = int(input())
    
    result = solution(numbers, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. 리스트의 슬라이싱을 사용하여 num1부터 num2+1까지 슬라이싱해준다.(마지막 인덱스의 원소를 포함시키기 위해 +1 을 해줌.)

***

### Q23(피자 나눠 먹기 (3))
```Python
def solution(slices, n):
    answer = 0
    
    if (n % slices == 0):
        answer = n / slices
    else:
        answer = int(n / slices + 1)
    
    return answer

if __name__ == "__main__":
    slices, n = int(input())
    
    result = solution(slices, n)
    print(result)
```
**주요 개념 및 로직**
1. 사람 수 n을 조각 slices로 나눈 나머지가 0이라면 딱 나눠떨어지는 것이므로, n을 slices로 나눈 몫을 answer에 할당하고,
2. 나머지가 0이 아니라면 n을 slices로 나눈 몫에 1을 더한 값을 int로 형변환하여 answer에 할당한다.

***

### Q24(점의 위치 구하기)
```Python
def solution(dot):
    answer = 0
    
    if (dot[0] > 0 and dot[1] > 0):
        answer = 1
    elif (dot[0] > 0 and dot[1] < 0):
        answer = 4
    elif (dot[0] < 0 and dot[1] > 0):
        answer = 2
    elif (dot[0] < 0 and dot[1] < 0):
        answer = 3
    
    return answer

if __name__ == "__main__":
    dot = list(map(int, input()))
    
    result = solution(dot)
    print(result)
```
**주요 개념 및 로직**
1. dot[0] = x, dot[1] = y 좌표라고 생각하고 조건문을 적절하게 분기하여 answer에 1, 2, 3, 4 중 하나의 값을 할당한다.

***

### Q25(배열의 유사도)
```Python
def solution(s1, s2):
    answer = 0
    
    for val in s1:
        if (val in s2):
            answer += 1

    return answer

if __name__ == "__main__":
    s1, s2 = input()
    
    result = solution(s1, s2)
    print(result)
```
**주요 개념 및 로직**
1. s1 리스트에 있는 원소들을 val에 담아 for문을 돌리는데, val 원소가 s2에도 있으면 answer의 개수를 하나씩 올린다.
2. 또 다른 풀이: len(set(s1)&set(s2)) <- 이런식으로 집합의 교집합 연산을 이용해서 구할 수도 있다.

***

### Q26(순서쌍의 개수)
```Python
def solution(n):
    answer = 0
    # pair_list = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer += 1
            # pair = (i, n // i)
            # pair_list.append(pair)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. i는 1부터 n+1 까지 반복한다:
2. n을 i로 나누어 떨어지면, 해당 값은 순서쌍이 되므로 answer에 +1을 해준다.
3. 주석 부분은 순서쌍을 튜플로 저장하는 부분. (문제에서는 필요없음.)

***

### Q27(n의 배수 고르기)
```Python
def solution(n, numlist):
    answer = []
    
    for num in numlist:
        if (num % n == 0):
            answer.append(num)
            
    # answer = [i for i in numlist if i%n==0]
            
    return answer

if __name__ == "__main__":
    n = int(input())
    numlist = list(map(int, input()))
    
    result = solution(n, numlist)
    print(result)
```
**주요 개념 및 로직**
1. numlist에 있는 원소들을 num에 담아 num을 n으로 나눴을 때 나머지가 0인(n의 배수인) 원소들만 answer 리스트에 붙인다.
2. 두 번째 방법은 리스트 컴프리헨션.

***

### Q28(배열 원소의 길이)
```Python
def solution(strlist):
    answer = []
    answer = [len(i) for i in strlist]
    
    # for i in strlist:
        # answer.append(len(i))
    
    return answer

if __name__ == "__main__":
    strlist = input()
    
    result = solution(strlist)
    print(result)
```
**주요 개념 및 로직**
1. strlist의 원소들 i의 길이들을 answer 리스트에 저장(리스트 컴프리헨션)
2. 다른 방법: for문을 이용한 방법

***

### Q29(아이스 아메리카노)
```Python
def solution(money):
    answer = []
    answer = [money // 5500, money % 5500]
    
    return answer

if __name__ == "__main__":
    money = int(input())
    
    result = solution(money)
    print(result)
```
**주요 개념 및 로직**
1. answer 배열은 money를 5500으로 나눈 정수 몫, money를 5500으로 나눈 나머지가 들어간다.

***

### Q30(문자열안에 문자열)
```Python
def solution(str1, str2):
    answer = 0
    
    if str2 in str1:
        answer = 1
    else:
        answer = 2
        
    # answer = 1 if str2 in str1 else 2
    
    return answer

if __name__ == "__main__":
    str1, str2 = input()
    
    result = solution(str1, str2)
    print(result)
```
**주요 개념 및 로직**
1. str2가 str1 안에 있으면 answer은 1, 없으면 2.
2. 두 번째 방법은 pythonic한 방법.

***

### Q31(문자 반복 출력하기)
```Python
def solution(my_string, n):
    answer = ''
    for i in range(len(my_string)):
        answer += my_string[i] * n
    return answer

if __name__ == "__main__":
    my_string = input()
    n = int(input())
    
    result = solution(my_string, n)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌려서 my_string의 한 글자씩 n을 곱하여 answer에 더한다.

***

### Q32(제곱수 판별하기)
```Python
def solution(n):
    answer = 0
    k = n ** 0.5
    answer = 1 if k % 1 == 0 else 2
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. n에 2/1 제곱을 한 수를 k라 하고, k를 1로 나눈 나머지가 0, 즉 정수일 때 answer에 1을 할당하고, 아니면 2를 할당한다.

***

### Q33(특정 문자 제거하기)
```Python
def solution(my_string, letter):
    answer = ''
    
    for i in range(len(my_string)):
        if (my_string[i] != letter):
            answer += my_string[i]
            
    return answer

if __name__ == "__main__":
    my_string = input()
    letter = input()
    
    result = solution(my_string, letter)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 길이만큼 for문을 돌리는데, my_string의 문자가 letter와 같지 않은 것만 answer에 더한다.

***

### Q34(모음 제거)
```Python
def solution(my_string):
    answer = ''
    vowel_list = ['a', 'e', 'i', 'o', 'u']
    
    for i in range(len(my_string)):
        if (my_string[i] not in vowel_list):
            answer += my_string[i]

    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 모음 리스트 vowel_list에 a, e, i, o, u를 넣어준다.
2. my_string의 길이만큼 for문을 돌려서 my_string의 문자가 vowel_list에 있지 않은 문자(자음)만 answer에 더한다.

***

### Q35(짝수 홀수 개수)
```Python
def solution(num_list):
    answer = []
    odd_count, even_count = 0, 0

    for num in num_list:
        if (num % 2 == 0):
            even_count += 1
        else:
            odd_count += 1
            
    answer.append(even_count)
    answer.append(odd_count)

    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    
    result = solution(num_list)
    print(result)
```
**주요 개념 및 로직**
1. 홀수, 짝수의 개수를 세는 변수를 0으로 초기화하고, num_list에 있는 원소들을 하나씩 순회하며 원소를 2로 나눈 나머지가 0(짝수)일때는 짝수 카운터에 1을, 홀수일때는 홀수 카운터에 1을 더한다.
2. 마지막에 answer 리스트에 짝수 카운터, 홀수 카운터의 값을 각각 붙여서 마무리한다.

***

### Q36(중복된 숫자 개수)
```Python
def solution(array, n):
    answer = 0
    
    answer = array.count(n)
    
    # for num in array:
    #     if (num == n):
    #         answer += 1
            
    return answer

if __name__ == "__main__":
    array = list(map(int , input()))
    n = int(input())
    
    result = solution(array, n)
    print(result)
```
**주요 개념 및 로직**
1. count()로 원소의 개수를 세는 방법이 있고, for문으로 해당 원소를 세는 방법이 있다.

***

### Q37(배열 두 배 만들기)
```Python
def solution(numbers):
    answer = []
    answer = [2 * i for i in numbers] # numbers에 있는 원소를 i라 할 때, 2 * i한 값들을 answer에 저장하라.
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers에 있는 원소를 i라 할 때, 2 * i 한 값들을 answer 리스트에 저장한다.

***

### Q38(중앙값 구하기)
```Python
def solution(array):
    answer = 0
    array = sorted(array)
    mid = len(array) // 2
    
    if len(array) % 2 == 1: # 홀수개
        answer = array[mid]
    else: # 짝수개
        answer = (array[mid-1] + array[mid]) / 2
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. array를 오름차순 정렬하고, mid 변수(array의 길이 / 2)를 선언한다.
2. array의 길이를 2로 나눈 나머지가 1이면 리스트의 개수가 홀수개이므로, 아까 선언한 mid가 중앙값이 된다.
3. 나머지가 0이면 리스트의 개수가 짝수개이므로, mid-1, mid를 더해 2로 나눈 값이 중앙값이 된다.

***

### Q39(짝수는 싫어요)
```Python
def solution(n):
    answer = []
    
    for i in range(n+1):
        if (i % 2 == 1):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 0부터 n+1까지 for문을 돌려 i를 2로 나눈 나머지가 1(홀수)일 때만 answer에 붙인다.

***

### Q40(옷 가게 할인 받기)
```Python
def solution(price):
    answer = 0
    
    if (price >= 100000 and price < 300000):
        answer = price * 0.95
    elif (price >= 300000 and price < 500000):
        answer = price * 0.9
    elif (price >= 500000):
        answer = price * 0.8
    else:
        answer = price
    
    return int(answer)

if __name__ == "__main__":
    price = int(input())
    
    result = solution(price)
    print(result)
```
**주요 개념 및 로직**
1. price에 따라 조건문을 적절히 분기해 5%는 0.95, 10%는 0.9, 20%는 0.8을 곱하고, answer는 정수형으로 반환한다.

***

### Q41(직각삼각형 출력하기)
```Python
if __name__ == "__main__":
    n = int(input())
    for i in range(1, n+1):
        print("*" * i)
```
**주요 개념 및 로직**
1. for문의 범위는 1부터 n+1까지주고, 줄 마다 *의 개수를 i와 곱하여 출력하면 된다.

***

### Q42(개미 군단)
```Python
def solution(hp):
    answer = 0
    
    ant1 = hp // 5 # 장군개미
    ant2 = hp % 5 // 3 # 병정개미
    ant3 = hp % 5 % 3 // 1 # 일개미
    
    answer += ant1 + ant2 + ant3
    
    return answer

if __name__ == "__main__":
    hp = int(input())
    
    result = solution(hp)
    print(result)
```
**주요 개념 및 로직**
1. ant1을 장군개미의 수, ant2를 병정개미의 수, ant3을 일개미의 수로 나타내면 다음과 같다.
2. 각자 구한 최소 개체의 수를 다 더하여 answer에 더하면 최소한의 병력이 산출된다.

***

### Q43(가위 바위 보)
```Python
def solution(rsp):
    answer = ''
    rsp_list = ['2', '0', '5'] # 순서대로 가위, 바위, 보

    for i in range(len(rsp)):
        idx = rsp_list.index(str(rsp[i]))
        answer += rsp_list[(idx + 1) % 3]
            
    return answer

if __name__ == "__main__":
    rsp = input()
    
    result = solution(rsp)
    print(result)
```
**주요 개념 및 로직**
1. 가위바위보 리스트 rsp_list에 2, 0, 5를 순서대로 담아준다.
2. 받은 문자열 rsp의 길이만큼 for문을 돌려 현재 인덱스에 해당하는 원소를 idx로 담아준다.
3. answer에는 다음 인덱스(ex) 2 -> 0, 0 -> 5, 5 -> 2)에 해당하는 원소를 담아준다.

***

### Q44(주사위의 개수)
```Python
def solution(box, n):
    answer = 1
    
    for val in box:
        answer *= (val // n)

    return answer

if __name__ == "__main__":
    box = list(map(int, input()))
    n = int(input())
    
    result = solution(box, n)
    print(result)
```
**주요 개념 및 로직**
1. box에 있는 가로, 세로, 높이를 각각 val로 담아, val을 n으로 나눈 정수 몫을 다 곱하여 answer에 저장한다. (상자에 들어갈 수 있는 주사위의 최대 개수 나옴)
2. 단순히 가로 * 세로 * 높이를 한 부피에서는 남는 공간을 고려하지 못해 정확한 값이 나오지 않음.

***

### Q45(문자열 정렬하기 (1))
```Python
def solution(my_string):
    answer = []
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer.append(int(val))
            
    return sorted(answer)

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 문자도 0부터 9까지 정렬가능하므로 my_string의 원소 val이 0부터 9 사이에 있을 경우, answer 리스트에 int로 형변환하여 붙이고, 정렬된 answer 리스트를 반환한다.

***

### Q46(숨어있는 숫자의 덧셈 (1))
```Python
def solution(my_string):
    answer = 0
    
    for val in my_string:
        if (val >= '0' and val <= '9'):
            answer += int(val)
            
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. 45번 문제와 동일하게 숫자로 된 원소들을 int로 형변환하여 answer에 다 더한다.

***

### Q47(최댓값 만들기 (2))
```Python
def solution(numbers):
    numbers = sorted(numbers)
    
    cand1 = numbers[0] * numbers[1]
    cand2 = numbers[-1] * numbers[-2]
    answer = max(cand1, cand2)
    
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input().split()))
    
    result = solution(numbers)
    print(result)
```
**주요 개념 및 로직**
1. numbers 리스트를 정렬하고, 음수와 음수를 곱한 최댓값과 양수와 양수를 곱한 최댓값을 cand1, cand2에 저장해서 둘 중 더 큰 것을 answer에 할당한다.

***

### Q48(암호 해독)
```Python
def solution(cipher, code):
    answer = ''
    
    for i in range(code-1, len(cipher), code):
        answer += cipher[i]
    
    return answer

if __name__ == "__main__":
    cipher = input()
    code = int(input())
    
    result = solution(cipher, code)
    print(result)
```
**주요 개념 및 로직**
1. code-1부터 cipher의 길이까지 step을 code크기로 cipher의 원소들을 answer에 붙인다.

***

### Q49(대문자와 소문자)
```Python
def solution(my_string):
    answer = ''
    my_string = list(my_string)
    
    for i in range(len(my_string)):
        if (my_string[i].islower()):
            my_string[i] = my_string[i].upper()
        elif (my_string[i].isupper()):
            my_string[i] = my_string[i].lower()
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트화 해주고, for문을 돌려서 my_string의 원소가 소문자인지, 대문자인지 판별 후, 소문자는 대문자로, 대문자는 소문자로 바꿔주는 작업을 실시한 후, 다시 string화 해준다.

***

### Q50(인덱스 바꾸기)
```Python
def solution(my_string, num1, num2):
    answer = ''
    my_string = list(my_string)
    
    temp = my_string[num1]
    my_string[num1] = my_string[num2] # 불변 객체라 스트링을 바로 바꿀 순 없음.
    my_string[num2] = temp # 마찬가지.
    
    answer = ''.join(my_string)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    num1, num2 = int(input())
    
    result = solution(my_string, num1, num2)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 리스트로 바꿔주고, temp에 num1 인덱스에 해당한 my_string 원소를 담아준다.
2. 그 후, num2 인덱스에 있던 원소를 num1 인덱스의 원소로 바꾸고,
3. num2 인덱스에 있던 원소를 temp로 바꾼다.
4. 마지막엔 다시 string화 시키기.

***

### Q51(약수 구하기)
```Python
def solution(n):
    answer = []
    
    for i in range(1, n+1):
        if (n % i == 0):
            answer.append(i)
            
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 1부터 n+1까지 n을 i로 나눈 나머지가 0인 값(i가 n의 약수)만 answer에 붙인다.

***

### Q52(가장 큰 수 찾기)
```Python
def solution(array):
    answer = []
    answer = [max(array), array.index(max(array))]
    
    return answer

if __name__ == "__main__":
    array = list(map(int, input()))
    
    result = solution(array)
    print(result)
```
**주요 개념 및 로직**
1. answer에 array에서 가장 큰 값, 그 값의 인덱스를 담는다.

***

### Q53(문자열 정렬하기(2))
```Python
def solution(my_string):
    answer = ''
    my_string = my_string.lower()
        
    answer = ''.join(sorted(my_string))
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string을 전부 소문자로 바꾼 것을 정렬하여 스트링으로 바꿔주면 된다.

***

### Q54(숫자 찾기)
```Python
def solution(num, k):
    answer = 0
    num = str(num)
    k = str(k)
    
    if (k in num):
        answer = num.index(k) + 1
    else:
        answer = -1
              
    return answer

if __name__ == "__main__":
    num, k = int(input())
    
    result = solution(num, k)
    print(result)
```
**주요 개념 및 로직**
1. num과 k를 스트링을 바꿔주고, k가 num에 있으면 그 인덱스 + 1을 answer에, 없으면 -1을 answer에 담는다.

***

### Q55(피자 나눠 먹기(2))
```Python
def solution(n):
    answer = 0
    i = 1
    
    while(1):
        if ((6 * i) % n == 0):
            break
        i += 1
        
    answer = i
    
    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 6판 * i를 n명 만큼 나눈 나머지가 0이 되는 로직을 통해 n명이 각자 똑같이 먹을 수 있는 최소 판을 구할 수 있다.
2. 초기에 i는 1부터 시작해 점점 증가하다가 n을 나눈 나머지가 0이 되는 순간 break를 통해 while문을 탈출한다. 그 i가 answer이다.

***

### Q56(외계행성의 나이)
```Python
def solution(age):
    answer = ''
    age = str(age)
    mapping = "abcdefghij"
    
    for num in age:
        answer += mapping[int(num)]
        
    return answer

if __name__ == "__main__":
    age = int(input())
    
    result = solution(age)
    print(result)
```
**주요 개념 및 로직**
1. age를 string화 해주고, mapping 문자열에 a~j까지 둔다.
2. age에 있는 숫자들을 돌며 그 숫자를 int로 형변환한 것이 mapping의 인덱스로 들어가, 매핑된 값을 answer에 이어붙인다.

***

### Q57(배열 회전시키기)
```Python
def solution(numbers, direction):
    answer = []
    
    if (direction == "right"):
        for i in range(len(numbers)):
            answer.append(numbers[(i - 1) % len(numbers)])
    elif (direction == "left"):
        for i in range(len(numbers)):
            answer.append(numbers[(i + 1) % len(numbers)])
            
    return answer

if __name__ == "__main__":
    numbers = list(map(int, input()))
    direction = input()
    
    result = solution(numbers, direction)
    print(result)
```
**주요 개념 및 로직**
1. 빈 리스트 answer에 direction이 left이면 numbers 리스트의 길이만큼 for문을 돌려 (i - 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (왼쪽으로 회전)
2. direction이 right이면 numbers 리스트의 길이만큼 for문을 돌려 (i + 1)에 numbers의 길이만큼 나눈 나머지에 해당하는 인덱스를 붙인다. (오른쪽으로 회전)

***

### Q58(369게임)
```Python
def solution(order):
    answer = 0
    order = str(order)
    
    for num in order:
        if (int(num) != 0 and int(num) % 3 == 0):
            answer += 1
    
    return answer

if __name__ == "__main__":
    order = int(input())
    
    result = solution(order)
    print(result)
```
**주요 개념 및 로직**
1. order를 스트링으로 바꿔주고, int로 형변환된 각 숫자마다 0이 아니고, 3의 배수(3, 6, 9)일 때, answer에 1을 더한다.

***

### Q59(합성수 찾기)
```Python
def solution(n):
    answer = 0
    new_list = []
    
    for i in range(1, n+1):
        count = 0
        for j in range(1, i+1):
            if (i % j == 0):
                count += 1
        new_list.append(count)
    
    answer = len([x for x in new_list if x >= 3])

    return answer

if __name__ == "__main__":
    n = int(input())
    
    result = solution(n)
    print(result)
```
**주요 개념 및 로직**
1. 합성수란 약수의 개수가 3개 이상인 수를 말하므로, 우선 n 이하의 합성수의 개수를 구하기 위해 1부터 n까지의 수의 합성수를 담을 리스트 new_list를 선언,
2. for문을 돌려 count의 개수를 매번 0으로 초기화, 두번째 for문에서는 1부터 해당 원소(i)까지 해당 원소를 j(1~i)로 나눈 값이 0이되는 값이 있을 때 count의 개수를 1 증가시킨다.
3. 각 i의 for문이 끝나면 계산된 카운트를 new_list에 붙인다.
4. 모든 for문이 끝나고 나면 new_list에는 n이하의 정수들의 합성수들의 개수가 담겨있게 되므로, len()과 리스트 컴프리헨션을 통해 count가 3 이상인 것들만 골라 합성수의 개수를 찾아낸다.

***

### Q60(중복된 문자 제거)
```Python
def solution(my_string):
    answer = ''
    lst = []
    for val in my_string:
        if (val not in lst):
            lst.append(val)
            
    answer = ''.join(lst)
    
    return answer

if __name__ == "__main__":
    my_string = input()
    
    result = solution(my_string)
    print(result)
```
**주요 개념 및 로직**
1. my_string의 문자들을 val이라고 했을 때, val이 lst에 없으면 val을 lst에 추가한다.
2. 마지막에 리스트 형태를 string으로 answer에 저장하고, 반환한다.

***

### Q61(모스부호 (1))
```Python
def solution(letter):
    answer = ''
    letter = list(letter.split(' '))
    morse = { 
    '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',
    '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',
    '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',
    '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',
    '-.--':'y','--..':'z'
    }
    for i in range(len(letter)):
        answer += morse[letter[i]]
        
    return answer

if __name__ == "__main__":
    letter = input()
    
    result = solution(letter)
    print(result)
```
**주요 개념 및 로직**
1. letter을 받고, 공백으로 분리해 리스트로 만든다.
2. morse 딕셔너리는 문제에서 주어진 그대로이다.
3. for문을 letter 리스트 길이만큼 돌려 각 원소(키)를 주면 그에 맞는 문자가 반환되어 answer에 담긴다.

***

### Q62(2차원으로 만들기)
```Python
def solution(num_list, n):
    answer = []
    
    row = len(num_list) // n
    col = n
    k = 0
    
    for i in range(row):
        answer.append([])
        for j in range(col):
            answer[i].append(num_list[k])
            k += 1
        
    return answer

if __name__ == "__main__":
    num_list = list(map(int, input()))
    n = int(input())
    
    result = solution(num_list, n)
    print(result)
```
**주요 개념 및 로직**
1. 행렬에서 사용될 row, col, k=0을 선언해주고,
2. 행 만큼 for문을 반복하여, 각 행마다 빈 리스트([])를 붙여주고, 열 만큼 for문을 반복하여, num_list의 원소들을 계속 가져와 answer의 각 행의 빈 리스트에 붙여넣는다.

***

### Q63(A로 B 만들기)
```Python
def solution(before, after):
    answer = 0
    answer = 1 if (sorted(before) == sorted(after)) else 0

    return answer

if __name__ == "__main__":
    before = input()
    after = input()
    
    result = solution(before, after)
    print(result)
```
**주요 개념 및 로직**
1. before 문장을 어떻게 조합해도 after와 같아지려면, 결국 구성하고 있는 문자의 개수가 같아야 한다.
2. 그렇기에, before 문장과 after 문장을 sorted()로 비교한 결과가 같으면 1, 같지 않으면 조합 불가능이므로 0이다.

***

### Q64(k의 개수)
```Python
def solution(i, j, k):
    answer = 0
    k = str(k)
    
    for num in range(i, j+1):
        answer += str(num).count(k)

    return answer

if __name__ == "__main__":
    i, j, k = int(input().split(' '))
    
    result = solution(i, j, k)
    print(result)
```
**주요 개념 및 로직**
1. 문자열로 비교하기 위해 k를 스트링으로 바꿔주고, i부터 j까지의 숫자도 string num으로 비교한다.
2. answer에는 num에 k가 들어있는 개수를 더하며 저장한다.

***

### Q65(한 번만 등장한 문자)
```Python
def solution(s):
    answer = ''
    answer = [x for x in set(s) if s.count(x) == 1]    
    answer = sorted(answer)
    
    return ''.join(answer)

if __name__ == "__main__":
    s = input()
    
    result = solution(s)
    print(result)
```
**주요 개념 및 로직**
1. 집합 s(s = {s에서 중복이 제거된 각 문자들})에서 문자들을 x라 하여 리스트에 저장한다.
2. 조건은 스트링 s에서 x(집합의 원소들)을 카운트한 것이 1인 원소들만 리스트에 저장한다.
3. answer은 리스트이므로, 반환할 때는 ''.join()을 사용해 스트링으로 바꿔준 뒤 반환한다.

***

### Q66(
